<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8" />
	<title>Редактор Уровней</title>
<style>
:root {
  /* Цвета */
  --bg-main: #f8f9fa;
  --text-color: #212529;
  --border-color: #ced4da;
  --btn-bg: #fff;
  --accent: #4a90e2;
  --danger: #ff4d4f;
  --secondary: #6c757d;

  /* Цвета слоёв */
  --layer-0: LimeGreen;  
  --layer-1: MediumOrchid;
  --layer-2: CornflowerBlue;
  --layer-3: Chocolate;

  /* Токены */
  --token-border: #999;

  /* Размеры */
  --radius: 8px;
  --gap: 1rem;
}

body {
  font-family: 'Segoe UI', sans-serif;
  background-color: var(--bg-main);
  margin: 0;
  padding: 20px;
  color: var(--text-color);
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
  justify-content: center;
}

/* === Карточки === */
.card {
  background: white;
  border-radius: var(--radius);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  padding: var(--gap);
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

.card h3,
.card h4 {
  margin-top: 0;
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}

.controls-section {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.layers-control,
.field-settings {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  align-items: center;
  text-align: center;
}

.layer-buttons {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
  border-width: 2px; /* Фиксируем ширину границы */
}

.layer-button.active {
  font-weight: bold;
  /* Не нужно менять border-width */
}

/* === Кнопки слоев === */
.layer-button {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  border-radius: var(--radius);
  cursor: pointer;
  background: var(--btn-bg);
  transition: all 0.2s ease;
  flex: 1 1 auto;
  min-width: 80px;
  text-align: center;
}

.layer-button.active {
  font-weight: bold;
  outline: 2px solid black;
}

.layer-button[data-layer="0"].active { background-color: var(--layer-0); color: white; }
.layer-button[data-layer="1"].active { background-color: var(--layer-1); color: white; }
.layer-button[data-layer="2"].active { background-color: var(--layer-2); color: white; }
.layer-button[data-layer="3"].active { background-color: var(--layer-3); color: white; }

.layer-button:hover:not(.active) {
  background-color: #f0f0f0;
}

/* === Формы === */
input[type="text"],
textarea {
  width: 100%;
  padding: 0.75rem;
  font-size: 1rem;
  border: 1px solid var(--border-color);
  border-radius: var(--radius);
  resize: vertical;
  transition: border 0.2s ease;
  box-sizing: border-box;
}

input:focus,
textarea:focus {
  border-color: var(--accent);
  outline: none;
}

/* === Кнопки действий === */
.action-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
  justify-content: center;
  margin-top: calc(var(--gap) * 2);
}

.action-buttons button i.material-icons {
  font-size: 18px;
  vertical-align: middle;
  margin-right: 6px;
}

.btn {
  padding: 0.75rem 1.25rem;
  border-radius: var(--radius);
  border: none;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.btn.primary {
  background-color: var(--accent);
  color: white;
}

.btn.danger {
  background-color: var(--danger);
  color: white;
}

.btn.secondary {
  background-color: var(--secondary);
  color: white;
}

.btn.tertiary {
  background-color: #e9ecef;
  color: var(--text-color);
}

.btn:hover {
  opacity: 0.9;
}

/* === Токены === */
.tokens-panel {
  min-height: 150px;
}

.token-item {
  display: inline-block;
  margin: 5px;
  cursor: grab;
  user-select: none;
  text-align: center;
  pointer-events: auto;
}

.token-item img {
  width: 60px;
  height: 60px;
  object-fit: contain;
  border: 2px solid var(--token-border);
  border-radius: 3px;
  padding: 2px;
}

.counter {
  font-size: 12px;
  color: gray;
  margin-top: -5px;
  text-align: center;
}

/* === Сетка === */
.main-grid-container {
  position: relative;
  width: 900px;
  aspect-ratio: 1 / 1;
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  grid-template-rows: repeat(10, 1fr);
  gap: 1px;
  background-color: transparent;
}

.grid-cell {
  width: 100%;
  height: 100%;
  background-color: transparent;
  box-sizing: border-box;
  position: relative;
  border: 1px solid var(--border-color);
}

.grid-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: contents;
}

.grid-field {
  position: absolute;
  cursor: move;
  user-select: none;
  width: 100%;
  height: 100%;
  pointer-events: auto;
  object-fit: contain;
  border: 2px solid black;
}

.token {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  max-width: 80%;
  max-height: 80%;
  pointer-events: auto;
  cursor: default !important;
  user-select: none;
}

.token-title {
  font-size: 12px;
  color: var(--text-color);
  text-align: center;
  margin-top: -3px;
}

.token.layer-1 { outline: 2px solid var(--layer-1); }
.token.layer-2 { outline: 2px solid var(--layer-2); }
.token.layer-3 { outline: 2px solid var(--layer-3); }

.selected {
  outline: 4px solid #ff0000 !important;
}

.level-info {
  margin-top: var(--gap);
}

.level-info-inner {
  max-width: 900px; /* совпадает с .main-grid-container */
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
  box-sizing: border-box;
}

.level-info-inner input[type="text"],
.level-info-inner textarea {
  width: 100%;
  font-size: 1rem;
  padding: 0.75rem;
  box-sizing: border-box;
}

/* === Зона корзины === */
.trash-zone {
  width: 15%;
  min-width: 180px;
  height: 900px; /* совпадает с .main-grid-container */
  background-color: #fff;
  border: 2px dashed var(--danger);
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  transition: background-color 0.3s ease;
}

.trash-icon {
  text-align: center;
  color: var(--danger);
}

.trash-icon i.material-icons {
  font-size: 48px;
  display: block;
}

.trash-icon span {
  font-size: 14px;
  margin-top: 10px;
  display: block;
  padding: 0 10px;
}

/* === Печать === */
@media print, screen and (-webkit-min-device-pixel-ratio: 0), not all and (min-resolution: .001dpcm) {
  .grid-cell::before {
    background-color: transparent !important;
  }
}

.print-mode .grid-cell {
  border: none !important;
}

.print-mode .token {
  outline: none !important;
}

.grid-cell::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ddd;
  z-index: -1;
}

.layers-and-fields {
  display: flex;
  justify-content: space-between;
  gap: var(--gap);
}

.layers-control,
.field-settings {
  flex: 1;
  min-width: 250px;
}

.fields-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  align-items: center;
  justify-content: center;
}

/* === Визуальное выделение парных жетонов на панели === */
.token-pair-wrapper {
  display: inline-block;
  margin: 2px;
}

.pair-overlay {
  display: flex;
  align-items: center;
  gap: 2px;
  background-color: #e9ecef; /* Серый фон */
  border-radius: var(--radius);
  padding: 4px 8px;
  margin: 2px;
}

/* === Мобильные устройства === */
@media (max-width: 768px) {
  html {
    font-size: 80%; /* Уменьшаем общий размер шрифта */
  }

  .main-grid-container {
    width: 95vw;
  }

  .container {
    flex-direction: column;
    align-items: stretch;
  }

  .controls-section {
    flex-direction: column;
  }

  .layer-buttons {
    flex-wrap: wrap;
  }

  input[type="text"],
  textarea {
    font-size: 0.85rem;
    padding: 0.5rem;
  }

  .card h3,
  .card h4 {
    font-size: 0.9rem;
  }

  .btn {
    font-size: 0.85rem;
    padding: 0.5rem 1rem;
  }

  .layers-and-fields {
    flex-direction: column;
  }

  .layers-control,
  .field-settings {
    width: 100%;
  }

  /* Уменьшаем кнопки СЛОЙ */
  .layer-button {
    font-size: 0.8rem;
    padding: 0.4rem 0.8rem;
  }

  /* Уменьшаем размеры токенов в 2 раза */
  .token-item img {
    width: 30px;
    height: 30px;
    padding: 1px;
    border-width: 0.5px;
  }

  .counter {
    font-size: 8px;
    margin-top: -3px;
  }

  .token-title {
    font-size: 8px;
    margin-top: -2px;
  }

  .action-buttons {
    margin-top: var(--gap);
    gap: 0.5rem;
  }

  .action-buttons button i.material-icons {
    font-size: 14px;
    margin-right: 4px;
  }

  /* Уменьшаем шрифт у чекбоксов */
  .fields-row label {
    font-size: 0.8rem;
    gap: 0.2rem;
    position: relative;
    padding-left: 0.5em; /* компенсация после скрытия текста */
  }

  .fields-row input[type="checkbox"] {
    transform: scale(0.8);
    margin-right: 0.2rem;
    position: absolute;
    opacity: 0;
    width: 0;
    height: 0;
  }
    .trash-zone {
    display: none;
  }
}
  @font-face {
    font-family: 'Material Icons';
    font-style: normal;
    font-weight: 400;
    src: url( https://22176.hostkey.in:34172/pictures/bg_editor/MaterialIcons-Regular.woff2 ) format('woff2');
    font-display: swap;
  }

    .material-icons {
    font-family: 'Material Icons';
    font-weight: normal;
    font-style: normal;
    font-size: 24px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
  }

  /* === Скрытие корзины при недостатке места === */
@media (max-width: 1200px) {
  .trash-zone {
    display: none;
  }
}

.puzzle-icon {
  width: 40px;
  height: 40px;
  object-fit: contain;
  border: 2px solid #ccc;
  border-radius: 5px;
  padding: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  background-color: #fff;
}

.puzzle-icon:hover {
  border-color: var(--accent);
  transform: scale(1.05);
}

.puzzle-icon.active {
  border-color: var(--accent);
  background-color: #e6f7ff;
  transform: scale(1.1);
}

</style>

<!-- Подключение Material Icons -->

</head>
<body>
<div class="container">

  <!-- Панель токенов -->
  <div class="card tokens-panel" id="tokensPanel">
    <div style="display: flex; align-items: center; justify-content: space-between;">
      <h3>Жетоны и фигурки</h3>

      <!-- Переключатель режима -->
        <select id="editorModeSwitcher">
          <option value="level">Редактор уровней</option>
          <option value="puzzle">Редактор головоломок</option>
        </select>

    <!-- Чекбокс использования бонусных токенов -->
    <label>
      <input type="checkbox" id="useBonusTokensCheckbox"> Использовать жетоны краудфандинга
    </label>
  </div>
 </div>


<!-- Управление сверху -->
<div class="controls-section card">
  <div class="layers-and-fields">
    <!-- Левая часть - Слои -->
    <div class="layers-control">
      <h4>Слои</h4>
      <div class="layer-buttons">
        <button class="layer-button" data-layer="0">Слой 0</button>
        <button class="layer-button active" data-layer="1">Слой 1</button>
        <button class="layer-button" data-layer="2">Слой 2</button>
        <button class="layer-button" data-layer="3">Слой 3</button>
      </div>
    </div>

	<!-- Правая часть - Поля -->
	<div class="field-settings">
	  <h4>Поля</h4>
	  <div class="fields-row">
		<input type="checkbox" checked data-field="4x4"> 4x4</label>
		<input type="checkbox" data-field="2x4_1" class="old-field"> 2x4 ↑</label>
		<input type="checkbox" data-field="2x4_2" class="old-field"> 2x4 ↑</label>
		<input type="checkbox" data-field="4x2_1" class="new-field"> 4x2 →</label>
		<input type="checkbox" data-field="4x2_2" class="new-field"> 4x2 →</label>
	  </div>
	</div>
  </div>
</div>

  <!-- Панель условий головоломок -->
  <div class="card" id="puzzlePanelIcons" style="display:none; text-align:center;">
    <div id="puzzleIconsContainer"
        style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;"></div>
  </div>

  <!-- Поле 10x10 -->
  <div class="main-grid-container" id="gridContainer">
    <div class="grid-layer" id="layer0"></div>
    <div class="grid-layer" id="layer1"></div>
    <div class="grid-layer" id="layer2"></div>
    <div class="grid-layer" id="layer3"></div>
  </div>

  <!-- Корзина для удаления токенов -->
  <div class="trash-zone" id="trashZone">
    <div class="trash-icon">
      <i class="material-icons">delete</i>
      <span>Перетащите сюда для удаления</span>
    </div>
  </div>

  <!-- Название и описание уровня -->
  <div class="level-info card">
    <div class="level-info-inner">
      <div>
        <label for="levelNameInput"><strong>Название уровня:</strong></label>
        <input type="text" id="levelNameInput" placeholder="Введите название уровня" />
      </div>
      <div style="margin-top: 1rem;">
        <label for="levelDescription"><strong>Описание уровня:</strong></label>
        <textarea id="levelDescription" rows="4" maxlength="1500"
                  placeholder="Введите описание уровня (максимум 1500 символов)"></textarea>
      </div>
    </div>
  </div>

	<!-- Кнопки -->
	<div class="action-buttons">
	  <button class="btn secondary" id="saveButton"><i class="material-icons">image</i> Сохранить как изображение</button>
	  <button class="btn primary" id="saveLevelButton"><i class="material-icons">save</i> Сохранить уровень</button>
	  <button class="btn tertiary" id="loadLevelButton"><i class="material-icons">folder_open</i> Загрузить уровень</button>
	  <button class="btn danger" id="clearButton"><i class="material-icons">delete_forever</i> Очистить всё</button>
	</div>

</div>

<div id="output" style="margin-top: 40px; text-align: center;"></div>

<!-- Canvas библиотека -->
<script src="https://22176.hostkey.in:34172/pictures/bg_editor/html2canvas.min.js"></script>
<script>

	  // Путь до изображений и помещаем их в локальный кэш
	const IMAGE_PREFIX = 'https://22176.hostkey.in:34172/pictures/bg_editor/';

	const tokens = [
	  { name: 'ВП', image: IMAGE_PREFIX + 'water.png', title: 'Вода ↑', pairGroup: 'water-portal' },
	  { name: 'ПВ', image: IMAGE_PREFIX + 'portal.png', title: '↓ Портал', pairGroup: 'water-portal' },
	  { name: 'ВК', image: IMAGE_PREFIX + 'water.png', title: 'Вода ↑', pairGroup: 'water-stone' },
	  { name: 'КВ', image: IMAGE_PREFIX + 'stone.png', title: '↓ Камень', pairGroup: 'water-stone' },
	  { name: 'Л', image: IMAGE_PREFIX + 'ice.png', title: 'Лёд' },
	  { name: 'Б', image: IMAGE_PREFIX + 'barell.png', title: 'Бочка' },
	  { name: 'Ц', image: IMAGE_PREFIX + 'goal.png', title: 'Целевая точка' },
	  { name: 'К↑', image: IMAGE_PREFIX + 'red_up.png', value: 'К1', title: 'Красный Голем' },
	  { name: 'C↑', image: IMAGE_PREFIX + 'blue_up.png', value: 'C1', title: 'Синий Голем' },
	  { name: 'З↑', image: IMAGE_PREFIX + 'green_up.png', value: 'З1', title: 'Зелёный Голем' },
	  { name: 'Ж↑', image: IMAGE_PREFIX + 'yellow_up.png', value: 'Ж1', title: 'Жёлтый Голем' },
	  { name: 'ПЛ', image: IMAGE_PREFIX + 'line_straight.png', title: 'Прямая линия ↑', pairGroup: 'line-pair' },
	  { name: 'УЛ', image: IMAGE_PREFIX + 'line_corner.png', title: '↓ Угловая линия', pairGroup: 'line-pair' },
    { name: 'ВУТ', image: IMAGE_PREFIX + 'duck.png', title: 'Вода с Уточкой ↑', pairGroup: 'bonus-pair' },
    { name: 'ПРЖ', image: IMAGE_PREFIX + 'spring.png', title: '↓ Прыжок', pairGroup: 'bonus-pair' },
	];
  
  const tokenLimits = {
  'ВП': 2, 'ПВ': 2,
  'ВК': 4, 'КВ': 4,
  'Л': 6,
  'Б': 5,
  'К1': 1,
  'C1': 1,
  'З1': 1,
  'Ж1': 1,
  'ПЛ': 4,
  'УЛ': 4,
  'ВУТ': 1,
  'ПРЖ': 1
  };
  
  const layers = [0, 1, 2, 3];
//  let currentLayer = 1;

// Инициализация позиций полей
	const fieldPositions = {
	  "4x4": { row: 0, col: 3 },
	  "2x4_1": { row: 0, col: 0 },
	  "2x4_2": { row: 0, col: 8 },
	  "4x2_1": { row: 0, col: 0 }, // Пример начальной позиции
	  "4x2_2": { row: 0, col: 6 }  // Пример начальной позиции
	};
	
	const userFieldPositions = {};

// Разрешенные жетоны для слоев
const allowedValues = {
  0: [], // Только фоновые поля
  1: ['ВП', 'ВК', 'КВ', 'ПВ', 'Л', 'Ц', 'Б', 'К1', 'C1', 'З1', 'Ж1', 'ПЛ', 'УЛ', 'ВУТ', 'ПРЖ'], 
  2: ['Л', 'Б', 'Ц', 'К1', 'C1', 'З1', 'Ж1'],
  3: ['Б', 'Ц', 'К1', 'C1', 'З1', 'Ж1']
};

 let currentLayer = 1;

  // Инициализация сетки: 10 строк × 10 столбцов
  const grid = Array.from({ length: 10 }, () =>
    Array.from({ length: 10 }, () => ['', '', '']) // layers 1, 2, 3
  );
  
  const gridContainer = document.getElementById('gridContainer');
  for (let row = 0; row < 10; row++) {
    for (let col = 0; col < 10; col++) {
      const cell = document.createElement('div');
      cell.classList.add('grid-cell');
      cell.dataset.row = row;
      cell.dataset.col = col;
      cell.addEventListener('dragover', e => e.preventDefault());

	cell.addEventListener('drop', e => {
	  e.preventDefault();
	  cell.style.backgroundColor = '';
	  if (currentLayer === 0) return;

	  const tokenName = e.dataTransfer.getData('text/plain');
	  const fromRow = parseInt(e.dataTransfer.getData('from-row'));
	  const fromCol = parseInt(e.dataTransfer.getData('from-col'));
	  const rotation = e.dataTransfer.getData('rotation'); // <-- Получаем поворот

	  const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
	  if (!token) return;

	  const tokenValue = token.value || token.name;
	  if (!allowedValues[currentLayer].includes(tokenValue)) {
		alert(`На слое ${currentLayer} нельзя разместить "${token.name}"`);
		return;
	  }

	  const row = parseInt(cell.dataset.row);
	  const col = parseInt(cell.dataset.col);
	  const layerIndex = currentLayer - 1;

	  // Если это перетаскивание с другой ячейки — удаляем из старой
	  if (!isNaN(fromRow) && !isNaN(fromCol)) {
		grid[fromRow][fromCol][layerIndex] = '';
	  }

	  grid[row][col][layerIndex] = token.name;

	  updateCell(cell, row, col);

	  // Применяем поворот к новому элементу
	  const rotationKey = `rotation_${row}_${col}_${token.name}_layer${currentLayer}`;
	  localStorage.setItem(rotationKey, rotation);

	  const img = cell.querySelector('.token');
	  if (img && rotation) {
		img.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
	  }

	  validateLimits();
	  updateTokenCounters();
	  saveStateToLocalStorage();
	});

      gridContainer.appendChild(cell);
    }
  }

const puzzleConditions = [
  // 1. Уровень сложности (картинки lvl1...lvl5)
  { key: 'lvl1', image: IMAGE_PREFIX + 'lvl1.png' },
  { key: 'lvl2', image: IMAGE_PREFIX + 'lvl2.png' },
  { key: 'lvl3', image: IMAGE_PREFIX + 'lvl3.png' },
  { key: 'lvl4', image: IMAGE_PREFIX + 'lvl4.png' },
  { key: 'lvl5', image: IMAGE_PREFIX + 'lvl5.png' },

  // 2–4. Бонусы (повтор, условие, атака, защита, бот1, бот2)
  { key: 'repeat2', image: IMAGE_PREFIX + 'repeat2.png' },
  { key: 'condition', image: IMAGE_PREFIX + 'condition.png' },
  { key: 'attack', image: IMAGE_PREFIX + 'attack.png' },
  { key: 'defense', image: IMAGE_PREFIX + 'defense.png' },
  { key: 'bot1', image: IMAGE_PREFIX + 'bot1.png' },
  { key: 'bot2', image: IMAGE_PREFIX + 'bot2.png' },

  // 5. Число строк программы (line1...line6, lineN)
  { key: 'line1', image: IMAGE_PREFIX + 'line1.png' },
  { key: 'line2', image: IMAGE_PREFIX + 'line2.png' },
  { key: 'line3', image: IMAGE_PREFIX + 'line3.png' },
  { key: 'line4', image: IMAGE_PREFIX + 'line4.png' },
  { key: 'line5', image: IMAGE_PREFIX + 'line5.png' },
  { key: 'line6', image: IMAGE_PREFIX + 'line6.png' },
  { key: 'lineN', image: IMAGE_PREFIX + 'lineN.png' }
];

const fieldImages = {
  "4x4": [
    IMAGE_PREFIX + "pole_4x4.png",
    IMAGE_PREFIX + "pole_4x4_alt.png"
  ],
  "2x4_1": [
    IMAGE_PREFIX + "pole_2x4_1.png",
    IMAGE_PREFIX + "pole_2x4_1_alt.png"
  ],
  "2x4_2": [
    IMAGE_PREFIX + "pole_2x4_2.png",
    IMAGE_PREFIX + "pole_2x4_2_alt.png"
  ],
  "4x2_1": [
    IMAGE_PREFIX + "pole_4x2_1.png",
    IMAGE_PREFIX + "pole_4x2_1_alt.png"
  ],
  "4x2_2": [
    IMAGE_PREFIX + "pole_4x2_2.png",
    IMAGE_PREFIX + "pole_4x2_2_alt.png"
  ]
};

// === Функция кэширования изображений ===
function cacheImage(url) {
  const cached = localStorage.getItem(`cached_image_${url}`);
  if (cached) return Promise.resolve(cached);

  return fetch(url)
    .then(response => response.blob())
    .then(blob => {
      const reader = new FileReader();
      return new Promise(resolve => {
        reader.onload = () => {
          localStorage.setItem(`cached_image_${url}`, reader.result);
          resolve(reader.result);
        };
        reader.readAsDataURL(blob);
      });
    })
    .catch(() => url); // fallback на исходный URL
}

// === Сбор всех уникальных URL изображений ===
  function getAllImageUrls() {
    const urls = new Set();
    tokens.forEach(token => {
      urls.add(token.image);
    });
    Object.keys(fieldPositions).forEach(key => {
      urls.add(IMAGE_PREFIX + `pole_${key}.png`);
      urls.add(IMAGE_PREFIX + `pole_${key}_alt.png`); // <-- добавлено
    });
      puzzleConditions.forEach(condition => {
      urls.add(condition.image);
    });
    return Array.from(urls);
  }

  async function preloadAllImages() {
    const urls = getAllImageUrls();
    const promises = urls.map(url => cacheImageWithExpiry(url));
    await Promise.all(promises);
    console.log("Все изображения (токены, поля, головоломки) закэшированы");
  }

preloadAllImages(); // Выполняем при загрузке страницы

function getCachedImageURL(url) {
  return localStorage.getItem(`cached_image_${url}`) || url;
}

// Проверка доступности локального хранилища
function isLocalStorageAvailable() {
  try {
    const test = '__test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch (e) {
    return false;
  }
}

if (!isLocalStorageAvailable()) {
  alert("localStorage недоступен. Сохранение невозможно.");
}

function updateCell(cell, row, col, layer = currentLayer) {
  cell.innerHTML = '';
  const layerIndex = layer - 1;

  for (let i = 0; i < 3; i++) {
    const tokenName = grid[row][col][i];
    if (tokenName) {
      const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
      if (token && token.image) {
        const img = document.createElement('img');
        const cachedSrc = localStorage.getItem(`cached_image_${token.image}`);
        img.src = getCachedImageURL(token.image);
        img.alt = tokenName;
        img.title = tokenName;
        img.className = 'token';
        img.crossOrigin = 'anonymous';

        // Класс текущего слоя
        if (i + 1 === layer) {
          img.classList.add('layer-' + layer);
        }

        // Выделение по клику
        img.onclick = () => {
          document.querySelectorAll('.token').forEach(t => t.classList.remove('selected'));
          img.classList.add('selected');
        };

        img.draggable = true;

		// === ВОССТАНОВЛЕНИЕ ПОВОРОТОВ ===
		const rotationKey = `rotation_${row}_${col}_${tokenName}_layer${i + 1}`;

		// Читаем поворот из localStorage
		let rotation = parseInt(localStorage.getItem(rotationKey)) || 0;

		// Применяем поворот к стилю
		img.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;

        // === Логика поворота правой кнопкой мыши ===
        img.oncontextmenu = function(e) {
          e.preventDefault();
          rotation = (rotation + 90) % 360;
          img.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
          localStorage.setItem(rotationKey, rotation);
          saveStateToLocalStorage();
        };

        // === Перетаскивание жетона ===
        let dragPreview = null;

        img.addEventListener('dragstart', e => {
          const cell = img.closest('.grid-cell');
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const layerIndex = i;
          const currentTokenLayer = layerIndex + 1;

          if (currentTokenLayer !== currentLayer) {
            e.preventDefault();
            return;
          }

          const tokenValue = token.value || token.name;
          if (!allowedValues[currentLayer].includes(tokenValue)) {
            e.preventDefault();
            return;
          }

          const tokenName = token.name;

          e.dataTransfer.setData('text/plain', tokenName);
          e.dataTransfer.setData('from-row', row);
          e.dataTransfer.setData('from-col', col);

          const rotationKey = `rotation_${row}_${col}_${token.name}_layer${currentTokenLayer}`;
          const rotation = parseFloat(localStorage.getItem(rotationKey)) || 0;
          e.dataTransfer.setData('rotation', rotation.toString());

          const size = 60;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');

          const imgForCanvas = new Image();
          imgForCanvas.src = getCachedImageURL(token.image);

          imgForCanvas.onload = () => {
            const angle = rotation * Math.PI / 180;
            ctx.translate(size / 2, size / 2);
            ctx.rotate(angle);
            ctx.drawImage(imgForCanvas, -size / 2, -size / 2, size, size);
            e.dataTransfer.setDragImage(canvas, size / 2, size / 2);
          };

          imgForCanvas.onerror = (err) => {
            console.error("Ошибка загрузки изображения:", err);
            e.preventDefault();
          };
        });

        img.addEventListener('dragend', () => {
          if (dragPreview) {
            dragPreview.remove();
            dragPreview = null;
          }
        });

        // Мобильные события (долгое нажатие / двойной тап)
        let lastTapTime = 0;
        let longPressTimer;

        img.ontouchstart = function(e) {
          longPressTimer = setTimeout(() => {
            grid[row][col][currentLayer - 1] = '';
            updateCell(cell, row, col);
            validateLimits();
            updateTokenCounters();
            saveStateToLocalStorage();
          }, 800);

          const now = new Date().getTime();
          const timeDiff = now - lastTapTime;
          if (timeDiff > 0 && timeDiff < 300) {
            rotation = (rotation + 90) % 360;
            img.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
            localStorage.setItem(rotationKey, rotation);
            // === Сохраняем всё состояние ===
			saveStateToLocalStorage();
          }
          lastTapTime = now;

          e.preventDefault();
        };

        img.ontouchend = function() {
          clearTimeout(longPressTimer);
        };

        cell.appendChild(img);
      }
    }
  }
}

// === Транслитерация кириллицы в латиницу ===
function transliterate(text) {
  const map = {
    'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd',
    'е': 'e', 'ё': 'yo', 'ж': 'zh', 'з': 'z', 'и': 'i',
    'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n',
    'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't',
    'у': 'u', 'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch',
    'ш': 'sh', 'щ': 'shch', 'ы': 'y', 'э': 'e', 'ю': 'yu',
    'я': 'ya', 'і': 'i', 'ї': 'yi', 'є': 'ye'
  };
  return text.split('')
    .map(char => map[char.toLowerCase()] || char)
    .join('')
    .replace(/[^a-zA-Z0-9]/g, '_')
    .toLowerCase();
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Delete' || e.key === 'Del') {
    const selected = document.querySelector('.token.selected');
    if (selected) {
      const cell = selected.closest('.grid-cell');
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      const layerIndex = [...document.querySelectorAll('.layer-button')]
                         .findIndex(btn => btn.classList.contains('active')) - 1;
      if (layerIndex >= 0) {
        grid[row][col][layerIndex] = '';
		updateCell(cell, row, col);
		validateLimits();
		updateTokenStyles();
		updateTokenCounters();
		saveStateToLocalStorage();
      }
    }
  }
});


// Сохранение при изменении "Название уровня"
document.getElementById('levelNameInput').addEventListener('input', () => {
  saveStateToLocalStorage();
});

// Сохранение при изменении "Описание уровня"
document.getElementById('levelDescription').addEventListener('input', () => {
  saveStateToLocalStorage();
});

// --- Функция для обновления стилей токенов ---
function updateTokenStyles() {
  const activeTokens = tokens.filter(t => {
    const tokenValue = t.value || t.name;
    return allowedValues[currentLayer].includes(tokenValue);
  });

  const limitsExceeded = areTokensAvailable();

  document.querySelectorAll('.token-item').forEach(div => {
    const img = div.querySelector('img');
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
    const tokenValue = token.value || token.name;

    if (!allowedValues[currentLayer].includes(tokenValue)) {
      div.style.opacity = '0.4';
      div.style.cursor = 'not-allowed';
      div.setAttribute('title', 'Нельзя разместить на этом слое');
      div.draggable = false;
    } else if (limitsExceeded[tokenValue]) {
      div.style.opacity = '0.4';
      div.style.cursor = 'not-allowed';
      div.setAttribute('title', 'Превышен лимит для этого жетона');
      div.draggable = false;
    } else {
      div.style.opacity = '1';
      div.style.cursor = 'grab';
      div.removeAttribute('title');
      div.draggable = true;
    }
  });
}

// --- Инициализация токенов ---

// Группируем токены по pairGroup
const groupedTokens = {};
tokens.forEach(token => {
  const group = token.pairGroup || token.name;
  if (!groupedTokens[group]) groupedTokens[group] = [];
  groupedTokens[group].push(token);
});

// Создаем элементы
Object.values(groupedTokens).forEach(group => {
  const isPair = group.length > 1;

  // Общая обёртка для группы (парных или одиночных)
  const wrapper = document.createElement('div');
  wrapper.classList.add('token-pair-wrapper');

  // Серая подложка
  const grayOverlay = document.createElement('div');
  grayOverlay.classList.add('pair-overlay');

  group.forEach(token => {
    const div = document.createElement('div');
    div.classList.add('token-item');

    // Обёртка для изображения и заголовка
    const wrapper = document.createElement('div');

    // Добавляем название, если оно есть
    if (token.title) {
      const title = document.createElement('div');
      title.className = 'token-title';
      title.textContent = token.title;
      wrapper.appendChild(title);
    }

    const img = document.createElement('img');
    img.src = getCachedImageURL(token.image);
    img.alt = token.name;
    img.title = token.name;

    if (token.pairGroup) {
        wrapper.dataset.pairGroup = token.pairGroup; // метка для контейнера
        img.dataset.pairGroup = token.pairGroup;     // метка для изображения
      
    }

    wrapper.appendChild(img);
    div.appendChild(wrapper);

    // Добавляем возможность перетаскивания
    div.draggable = true;
    div.addEventListener('dragstart', e => {
      const tokenValue = token.value || token.name;
      if (!allowedValues[currentLayer].includes(tokenValue)) {
        e.preventDefault();
      } else {
        e.dataTransfer.setData('text/plain', token.name);
      }
    });

    grayOverlay.appendChild(div);
  });

  wrapper.appendChild(grayOverlay);
  tokensPanel.appendChild(wrapper);
});

updateTokenStyles();

document.querySelectorAll('.token-item').forEach(div => {
  div.addEventListener('dragstart', e => {
    const img = div.querySelector('img');
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
    const tokenValue = token?.value || token?.name;

    // Проверяем, можно ли размещать этот токен на текущем слое
    if (!allowedValues[currentLayer].includes(tokenValue)) {
      e.preventDefault(); // Запрещаем перетаскивание, если токен не подходит
    } else {
      e.dataTransfer.setData('text/plain', token.name); // Передаем имя токена
    }
  });
});

document.querySelectorAll('.token-item').forEach(div => {
  let tokenName = div.querySelector('img')?.alt;
  let longPressTimer;

	// === Поддержка перетаскивания жетонов на мобильных устройствах ===
	let isDragging = false;
	let dragPreview = null;

	div.addEventListener('touchstart', function(e) {
	
	  e.preventDefault(); // <-- Основное решение
	
	  const tokenName = this.querySelector('img')?.alt;
	  const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
	  const tokenValue = token?.value || token?.name;

	  if (!allowedValues[currentLayer].includes(tokenValue)) {
		e.preventDefault();
		return;
	  }

	  // Создаем прозрачный элемент-представление
	  dragPreview = document.createElement('img');
	  dragPreview.src = getCachedImageURL(token.image);
	  dragPreview.style.position = 'fixed';
	  dragPreview.style.top = '0px';
	  dragPreview.style.left = '0px';
	  dragPreview.style.width = '60px';
	  dragPreview.style.height = '60px';
	  dragPreview.style.opacity = '0.5';
	  dragPreview.style.pointerEvents = 'none';
	  dragPreview.style.zIndex = '9999';
	  dragPreview.style.transform = 'translate(-50%, -50%)';
	  document.body.appendChild(dragPreview);

	  isDragging = true;

	  const touch = e.touches[0];
	  updateDragPreviewPosition(touch.clientX, touch.clientY);

	  // Эмулируем начало drag
	  const event = new MouseEvent('mousedown', {
		clientX: touch.clientX,
		clientY: touch.clientY,
		bubbles: true
	  });
	  div.dispatchEvent(event);
	});

	div.addEventListener('touchmove', function(e) {
	  if (!isDragging) return;
	  
	  e.preventDefault(); // <-- Отменяем прокрутку при движении
	  
	  const touch = e.touches[0];
	  updateDragPreviewPosition(touch.clientX, touch.clientY);

	  const event = new MouseEvent('mousemove', {
		clientX: touch.clientX,
		clientY: touch.clientY,
		bubbles: true
	  });
	  div.dispatchEvent(event);
	});

	div.addEventListener('touchend', function(e) {
	  if (dragPreview) {
		dragPreview.remove();
		dragPreview = null;
	  }
	  isDragging = false;

	  const event = new MouseEvent('mouseup', {
		bubbles: true
	  });
	  div.dispatchEvent(event);

	  // Эмулируем drop на ячейке под пальцем
	  const touch = e.changedTouches[0];
	  const target = document.elementFromPoint(touch.clientX, touch.clientY);
	  const cell = target.closest('.grid-cell');
	  if (cell) {
		const dropEvent = new DragEvent('drop', {
		  dataTransfer: new DataTransfer(),
		  bubbles: true,
		  cancelable: true
		});

		const tokenName = this.querySelector('img')?.alt;
		dropEvent.dataTransfer.setData('text/plain', tokenName); // tokenName доступен здесь
		cell.dispatchEvent(dropEvent);
	  }
	});

	function updateDragPreviewPosition(x, y) {
	  if (dragPreview) {
		dragPreview.style.top = `${y}px`;
		dragPreview.style.left = `${x}px`;
	  }
	}

});

// --- Событие dragover и drop на ячейках сетки ---
document.querySelectorAll('.grid-cell').forEach(cell => {
  cell.addEventListener('dragover', e => {
    e.preventDefault();
    cell.style.backgroundColor = '#aaffaa'; // Подсветка
  });

  cell.addEventListener('dragleave', () => {
    cell.style.backgroundColor = ''; // Сброс подсветки
  });

cell.addEventListener('drop', e => {
  e.preventDefault();
  cell.style.backgroundColor = '';
  if (currentLayer === 0) return;

  const tokenName = e.dataTransfer.getData('text/plain');

	const fromRow = parseInt(e.dataTransfer.getData('from-row'), 10);
	const fromCol = parseInt(e.dataTransfer.getData('from-col'), 10);

	if (!isNaN(fromRow) && !isNaN(fromCol)) {
	  const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
	  if (fromCell) {
		updateCell(fromCell, fromRow, fromCol);
	  } else {
		console.warn("Could not find fromCell", { fromRow, fromCol });
	  }
	}

  // <-- Получаем поворот -->
  const rotation = e.dataTransfer.getData('rotation');

  const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
  if (!token) return;

  const tokenValue = token.value || token.name;
  if (!allowedValues[currentLayer].includes(tokenValue)) {
    alert(`На слое ${currentLayer} нельзя разместить "${token.name}"`);
    return;
  }

  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  const layerIndex = currentLayer - 1;

  // Удаляем из старой ячейки
  if (!isNaN(fromRow) && !isNaN(fromCol)) {
    grid[fromRow][fromCol][layerIndex] = '';
	if (!isNaN(fromRow) && !isNaN(fromCol)) {
	  const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
	  if (fromCell) {
		updateCell(fromCell, fromRow, fromCol);
	  } else {
		console.warn("Could not find cell to update", fromRow, fromCol);
	  }
	}
  }

  // Добавляем в новую
  grid[row][col][layerIndex] = token.name;
  updateCell(cell, row, col);
  
  // <-- Сохраняем поворот для нового места -->
  const rotationKey = `rotation_${row}_${col}_${token.name}_layer${currentLayer}`;
  localStorage.setItem(rotationKey, rotation);

  const img = cell.querySelector('.token');
  if (img && rotation) {
    img.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
  }

  // Проверяем лимиты
  if (!validateLimits(row, col, layerIndex)) {
    grid[row][col][layerIndex] = '';
    updateCell(cell, row, col);
  }

  updateTokenCounters();
  updateTokenStyles();
  saveStateToLocalStorage();
});

});


  // --- Обновление стилей при смене слоя ---
  document.querySelectorAll('.layer-button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.layer-button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentLayer = parseInt(btn.dataset.layer);

      // Убираем выделение у всех токенов
      document.querySelectorAll('.token.selected').forEach(token => {
        token.classList.remove('selected');
      });

      // Обновляем отображение ячеек
      document.querySelectorAll('.grid-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        updateCell(cell, row, col, currentLayer);
        
      });

      const fieldImageIndices = {};
      document.querySelectorAll('.grid-field').forEach(img => {
        fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
      });
      drawGameFields(fieldImageIndices);

      updateTokenStyles(); // обновляем стили токенов
      updateTokenCounters(); // <-- добавлено
      saveStateToLocalStorage();
    });
  });

    document.querySelectorAll('[data-field]').forEach(cb => {
      cb.addEventListener('change', () => {
        const fieldImageIndices = {};
        document.querySelectorAll('.grid-field').forEach(img => {
          fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
        });
        drawGameFields(fieldImageIndices);
      });
    });


  function drawGameFields(imageIndices = {}) {
    const layer0 = document.getElementById('layer0');
    layer0.innerHTML = ''; // Очищаем текущие элементы

    const activeElements = [];
    document.querySelectorAll('[data-field]').forEach(cb => {
      const key = cb.dataset.field;
      if (cb.checked) {
        const pos = userFieldPositions[key] || fieldPositions[key] || { row: 0, col: 0 };
        let rowsSpan, colsSpan;
        if (key === '4x4') {
          rowsSpan = colsSpan = 4;
        } else if (key.startsWith('2x4')) {
          rowsSpan = 4;
          colsSpan = 2;
        } else if (key.startsWith('4x2')) {
          rowsSpan = 2;
          colsSpan = 4;
        }

        const images = fieldImages[key];
        const index = imageIndices[key] || parseInt(localStorage.getItem(`fieldImageIndex_${key}`)) || 0;
        const imgUrl = images[index];

        const cachedUrl = getCachedImageURL(imgUrl);
        const img = createField(cachedUrl, key, pos.row, pos.col, rowsSpan, colsSpan);
        img.dataset.imageIndex = index; // <-- Запоминаем индекс изображения

        layer0.appendChild(img);
        activeElements.push(img);
      }
    });

    if (currentLayer === 0) makeDraggable(activeElements);
  }

  function createField(src, key, row, col, rowsSpan, colsSpan) {
    const img = document.createElement('img');
    img.src = src;
    img.dataset.fieldKey = key;
    img.classList.add('grid-field');
    img.style.gridRowStart = row + 1;
    img.style.gridColumnStart = col + 1;
    img.style.gridRowEnd = `span ${rowsSpan}`;
    img.style.gridColumnEnd = `span ${colsSpan}`;

    // === Событие ПКМ (для десктопа) ===
    img.addEventListener("contextmenu", function (e) {
      e.preventDefault(); // отключаем контекстное меню
      const currentSrc = this.src;
      const images = fieldImages[key];
      if (!images || images.length < 2) return;

      let currentIndex = images.indexOf(currentSrc);
      let nextIndex = (currentIndex + 1) % images.length;
      const newSrc = getCachedImageURL(images[nextIndex]);
      this.src = newSrc;

      // === Получаем реальные координаты из стиля grid ===
      const currentCol = parseInt(this.style.gridColumnStart) - 1; // колонка (0–9)
      const currentRow = parseInt(this.style.gridRowStart) - 1;    // строка (0–9)

      // Обновляем позицию в userFieldPositions
      userFieldPositions[key] = { row: currentRow, col: currentCol };

      saveStateToLocalStorage();
    });

    // === Событие долгого нажатия (для мобильных) ===
    let longPressTimer;
    img.addEventListener('touchstart', function (e) {
      e.preventDefault();

      // Запускаем таймер долгого нажатия
      longPressTimer = setTimeout(() => {
        // Тоже самое, что и при ПКМ
        const currentSrc = this.src;
        const images = fieldImages[key];
        if (!images || images.length < 2) return;

        let currentIndex = images.indexOf(currentSrc);
        let nextIndex = (currentIndex + 1) % images.length;
        const newSrc = getCachedImageURL(images[nextIndex]);
        this.src = newSrc;

        // === Получаем текущую позицию из grid CSS свойств ===
        const currentRow = parseInt(this.style.gridColumnStart) - 1;
        const currentCol = parseInt(this.style.gridRowStart) - 1;

        // Обновляем позицию в userFieldPositions
        userFieldPositions[key] = { row: currentRow, col: currentCol };

        saveStateToLocalStorage();
      }, 800); // 800 мс — длительность долгого нажатия
    });


    


    img.addEventListener('touchend', function (e) {
      clearTimeout(longPressTimer); // Отменяем действие, если нажатие короткое
    });

    img.addEventListener('touchmove', function (e) {
      clearTimeout(longPressTimer); // Отменяем при движении пальца
    });

    return img;
  }


function makeDraggable(elements) {
  for (const el of elements) {
    el.style.zIndex = 1000;
    el.draggable = false;

    let shiftX = 0, shiftY = 0;
    let isDragging = false;
    let touchId = null; // Для отслеживания конкретного касания

    function getEventClientX(e) {
      return e.touches ? e.touches[0].clientX : e.clientX;
    }

    function getEventClientY(e) {
      return e.touches ? e.touches[0].clientY : e.clientY;
    }

    function handleMouseDown(e) {
      if (currentLayer !== 0) return;
      e.preventDefault();

      const rect = gridContainer.getBoundingClientRect();
      const computedStyle = getComputedStyle(gridContainer);
      const paddingLeft = parseFloat(computedStyle.paddingLeft);
      const paddingTop = parseFloat(computedStyle.paddingTop);
      const actualWidth = rect.width - paddingLeft * 2;
      const actualHeight = rect.height - paddingTop * 2;
      const cellWidth = actualWidth / 10;
      const cellHeight = actualHeight / 10;

      shiftX = getEventClientX(e) - el.getBoundingClientRect().left;
      shiftY = getEventClientY(e) - el.getBoundingClientRect().top;

      const colsSpan = parseInt(el.style.gridColumnEnd.replace('span ', ''), 10);
      const rowsSpan = parseInt(el.style.gridRowEnd.replace('span ', ''), 10);

      function moveAt(pageX, pageY) {
        const x = pageX - rect.left - shiftX;
        const y = pageY - rect.top - shiftY;

        const col = Math.floor(x / cellWidth);
        const row = Math.floor(y / cellHeight);

        const safeCol = Math.max(0, Math.min(10 - colsSpan, col));
        const safeRow = Math.max(0, Math.min(10 - rowsSpan, row));

        el.style.gridColumnStart = safeCol + 1;
        el.style.gridRowStart = safeRow + 1;

//        const fieldKey = el.src.split('/').pop().replace('.png', '').replace('pole_', '');
        const fieldKey = el.dataset.fieldKey;
        userFieldPositions[fieldKey] = { row: safeRow, col: safeCol };
        saveStateToLocalStorage();
      }

      function onMouseMove(ev) {
        moveAt(getEventClientX(ev), getEventClientY(ev));
      }

      function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        document.removeEventListener('touchmove', onMouseMove);
        document.removeEventListener('touchend', onMouseUp);
        isDragging = false;
        touchId = null;
      }

      if (e.type === 'touchstart') {
        touchId = e.touches[0].identifier;
      }

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('touchmove', onMouseMove, { passive: false });
      document.addEventListener('touchend', onMouseUp);

      isDragging = true;
    }

    el.addEventListener('mousedown', handleMouseDown);
    el.addEventListener('touchstart', handleMouseDown, { passive: false });

    el.ondragstart = () => false;
  }
}

function countTokens() {
  const counts = {};
  for (let row of grid) {
    for (let cell of row) {
      for (let tile of cell) {
        if (!tile) continue;
        const token = tokens.find(t => t.name === tile || t.value === tile);
        const key = token?.value || token?.name;
        if (key && !counts[key]) counts[key] = 0;
        if (key) counts[key]++;
      }
    }
  }
  return counts;
}

// Просчет и проверка лимитов жетонов
function validateLimits(triggeringRow = null, triggeringCol = null, triggeringLayer = null) {
	const counts = countTokens();

	const red = (counts['К1'] || 0);
	const blue = (counts['C1'] || 0);
	const green = (counts['З1'] || 0);
	const yellow = (counts['Ж1'] || 0);

	const portalCount = (counts['ВП'] || 0) + (counts['ПВ'] || 0);
	const stoneCount = (counts['ВК'] || 0) + (counts['КВ'] || 0);
	const waterSurfaceCount = (counts['ВК'] || 0); // только ВК считается за водную поверхность
	const stoneSurfaceCount = (counts['КВ'] || 0); // только КВ считается за каменную поверхность
	const lineCount = (counts['ПЛ'] || 0) + (counts['УЛ'] || 0);
  const bonusCount = (counts['ВУТ'] || 0) + (counts['ПРЖ'] || 0);

	const exceeded = [];

	if (portalCount > 2)
	  exceeded.push("Максимум 2 портала!");

	if (stoneCount > 4)
	  exceeded.push("Максимум 4 камня/водной поверхности вместе!");

	if (waterSurfaceCount > 6)
	  exceeded.push("Превышено количество водных поверхностей!");

	if ((counts['Б'] || 0) > 5)
	  exceeded.push("Максимум 5 бочек!");

	if ((counts['Л'] || 0) > 6)
	  exceeded.push("Максимум 6 жетонов Льда!");
  if (red > 1) exceeded.push("Только один красный голем!");
  if (blue > 1) exceeded.push("Только один синий голем!");
  if (green > 1) exceeded.push("Только один зелёный голем!");
  if (yellow > 1) exceeded.push("Только один жёлтый голем!");
  
  if (lineCount > 4) exceeded.push("Максимум 4 жетона линий (ПЛ/УЛ)!");
  if (bonusCount > 1) exceeded.push("Максимум 1 жетона уточка-пружина (ВУТ/ПРЖ)!");

  updateTokenCounters(); // <-- всегда обновляем счетчики после валидации

  if (exceeded.length > 0 && triggeringRow !== null) {
    console.warn("Превышен лимит:", exceeded);
    return false;
  }

  updateTokenStyles();

  return exceeded.length === 0;

//  return true;
}

// Обновление счетчика под жетонами
  function updateTokenCounters() {
    const counts = countTokens();
    document.querySelectorAll('.token-item').forEach(div => {
      const img = div.querySelector('img');
      const tokenName = img.alt;
      const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
      const tokenValue = token?.value || token?.name;
      const limit = tokenLimits[tokenValue] || 0;
      const current = counts[tokenValue] || 0;
      let counter = div.querySelector('.counter');
      if (!counter) {
        counter = document.createElement('div');
        counter.className = 'counter';
        div.appendChild(counter);
      }
      counter.textContent = `${current}/${limit}`;
    });
  }

// Включение  и выключение токенов по лимиту
// Проверяет, превышен ли лимит у токенов (возвращает объект с флагами)
function areTokensAvailable() {
  const counts = countTokens();
  const limitsExceeded = {};

  // Суммы по группам
  const red = ['К1'].reduce((sum, k) => sum + (counts[k] || 0), 0);
  const blue = ['C1'].reduce((sum, k) => sum + (counts[k] || 0), 0);
  const green = ['З1'].reduce((sum, k) => sum + (counts[k] || 0), 0);
  const yellow = ['Ж1'].reduce((sum, k) => sum + (counts[k] || 0), 0);

  const portalCount = (counts['ВП'] || 0) + (counts['ПВ'] || 0); // портальные токены
  const stoneWaterCount = (counts['ВК'] || 0) + (counts['КВ'] || 0); // камень + вода

  // Проверяем отдельные лимиты
  limitsExceeded['ВП'] = limitsExceeded['ПВ'] = portalCount >= 2;
  limitsExceeded['ВК'] = limitsExceeded['КВ'] = stoneWaterCount >= 4; // Теперь ВК тоже имеет лимит 4 вместе с КВ
  limitsExceeded['Л'] = (counts['Л'] || 0) >= 6;
  limitsExceeded['Б'] = (counts['Б'] || 0) >= 5;
  limitsExceeded['Ц'] = false; // Цель всегда доступна

  // Големы: красный, синий, зелёный, жёлтый — только по одному на поле
	limitsExceeded['К1'] = red >= 1;
	limitsExceeded['C1'] = blue >= 1;
	limitsExceeded['З1'] = green >= 1;
	limitsExceeded['Ж1'] = yellow >= 1;
  
  // Линии прямая-угол
  const lineCount = (counts['ПЛ'] || 0) + (counts['УЛ'] || 0);
  limitsExceeded['ПЛ'] = limitsExceeded['УЛ'] = lineCount >= 4;

  // Бонус Уточка - Пружина
  const bonusCount = (counts['ВУТ'] || 0) + (counts['ПРЖ'] || 0);
  limitsExceeded['ВУТ'] = limitsExceeded['ПРЖ'] = bonusCount >= 1;

  return limitsExceeded;
}

//Запись состояния поля в локальное хранилище
function saveStateToLocalStorage() {
	
  const nameInput = document.getElementById('levelNameInput');
  const descriptionInput = document.getElementById('levelDescription');
	
  const checkboxes = Object.fromEntries(
    Array.from(document.querySelectorAll('[data-field]')).map(cb => [
      cb.dataset.field,
      cb.checked
    ])
  );
  
  // Сохраняем состояние чек-бокса бонус жетонов
  const bonusCheckbox = document.getElementById('useBonusTokensCheckbox');
  localStorage.setItem('useBonusTokens', bonusCheckbox?.checked);

  const state = {
    version: 2,
    grid,
    checkboxes,
    name: nameInput?.value || '',
    description: descriptionInput?.value || '',
    editorMode: editorModeSwitcher.value,
    puzzleIcons: selectedPuzzleIcons,
    currentLayer,
    userFieldPositions, // <-- Это должно быть здесь
    fieldImageIndices: Object.fromEntries(
      Array.from(document.querySelectorAll('.grid-field')).map(img => [
        img.dataset.fieldKey,
        parseInt(img.dataset.imageIndex || '0')
      ])
    )
  };
  localStorage.setItem('mapEditorState', JSON.stringify(state));

  const rotations = {};

  // === Правильный селектор для получения токенов на поле ===
  const tokenElements = document.querySelectorAll('img.token');

  if (tokenElements.length === 0) {
    console.warn("Нет токенов для сохранения");
    localStorage.setItem('tokenRotations', '{}');
    return;
  }

  // Получаем текущий активный слой
  const buttons = document.querySelectorAll('.layer-button');
  const activeIndex = [...buttons].findIndex(btn => btn.classList.contains('active'));
  let layerIndex = 1;
  if (activeIndex !== -1) {
    layerIndex = activeIndex + 1;
  }

  // === Обрабатываем реальные DOM-токены ===
  for (const img of tokenElements) {
    const cell = img.closest('.grid-cell');
    const row = cell?.dataset.row;
    const col = cell?.dataset.col;
    const tokenName = img.alt;
    const transform = img.style.transform;


	function extractRotation(transform) {
	  const rotateStart = transform.indexOf('rotate(');
	  if (rotateStart === -1) return null;

	  const degIndex = transform.indexOf('deg', rotateStart);
	  if (degIndex === -1) return null;

	  let rotationStr = transform.substring(rotateStart + 7, degIndex).trim();
	  let rotation = parseFloat(rotationStr);

	  return isNaN(rotation) ? null : rotation;
	}

	// === Использование ===
	const rotation = extractRotation(transform);
	if (rotation !== null) {
//	  const layerIndex = [...document.querySelectorAll('.layer-button')]
//						 .findIndex(btn => btn.classList.contains('active')) + 1;
//	  const key = `rotation_${row}_${col}_${tokenName}_layer${layerIndex}`;

	// Найдём, на каком слое этот токен реально находится
	let tokenLayer = 0;
	for (let i = 0; i < 3; i++) {
	  if (grid[row][col][i] === tokenName) {
		tokenLayer = i + 1; // слои от 1 до 3
		break;
	  }
	}

	const key = `rotation_${row}_${col}_${tokenName}_layer${tokenLayer}`;
	rotations[key] = rotation;
		
	} else {
	  console.warn(`Не удалось распознать поворот у токена: ${tokenName}`);
	}

  }

  localStorage.setItem('tokenRotations', JSON.stringify(rotations));

}

// Загрузка состояния поля из локального хранилища
function loadStateFromLocalStorage() {
  const savedState = localStorage.getItem('mapEditorState');

  if (savedState) {
    try {
      const parsedState = JSON.parse(savedState);

      if (parsedState.version === undefined) {
      // Это очень старый файл — примените миграцию
      }

      // === Загрузка puzzleIcons с проверкой на существование ===
      if (parsedState?.puzzleIcons) {
        selectedPuzzleIcons = [...parsedState.puzzleIcons];
      } else {
        selectedPuzzleIcons = ['', '', '', '', '']; // дефолт
      }

      // Восстанавливаем сетку
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 10; col++) {
          if (parsedState.grid?.[row]?.[col]) {
            grid[row][col] = [...parsedState.grid[row][col]];
          }
        }
      }

      // Восстанавливаем позиции фоновых полей
      Object.keys(userFieldPositions).forEach(key => delete userFieldPositions[key]);
      if (parsedState.userFieldPositions && Object.keys(parsedState.userFieldPositions).length > 0) {
        Object.assign(userFieldPositions, parsedState.userFieldPositions);
      } else {
        // Дефолтные значения
        userFieldPositions["4x4"] = { row: 0, col: 3 };
        userFieldPositions["2x4_1"] = { row: 0, col: 0 };
        userFieldPositions["2x4_2"] = { row: 0, col: 8 };
        userFieldPositions["4x2_1"] = { row: 0, col: 0 };
        userFieldPositions["4x2_2"] = { row: 0, col: 6 };
      }

      // Восстанавливаем чекбоксы
      if (parsedState.checkboxes) {
        document.querySelectorAll('[data-field]').forEach(cb => {
          const key = cb.dataset.field;
          if (parsedState.checkboxes[key] !== undefined) {
            cb.checked = parsedState.checkboxes[key];
          }
        });
      }

	// Восстанавливаем название уровня
	const nameInput = document.getElementById('levelNameInput');
	if (nameInput && parsedState.name !== undefined) {
	  nameInput.value = parsedState.name;
	}

	// Восстанавливаем описание уровня
	const descriptionInput = document.getElementById('levelDescription');
	if (descriptionInput && parsedState.description !== undefined) {
	  descriptionInput.value = parsedState.description;
	}

        // === ВОССТАНОВЛЕНИЕ ТЕКУЩЕГО СЛОЯ ===
      if (parsedState.currentLayer !== undefined) {
        currentLayer = parsedState.currentLayer;

        // Обновляем UI: подсвечиваем правильную кнопку слоя
        const buttons = document.querySelectorAll('.layer-button');
        buttons.forEach(btn => btn.classList.remove('active'));
        const activeButton = [...buttons].find(btn => parseInt(btn.dataset.layer) === currentLayer);
        if (activeButton) {
          activeButton.classList.add('active');
        }
      } else {
        currentLayer = 1; // дефолтное значение
      }

      drawGameFields(parsedState.fieldImageIndices || {});

      if (parsedState.fieldImageIndices && Object.keys(parsedState.fieldImageIndices).length > 0) {
        Object.entries(parsedState.fieldImageIndices).forEach(([key, index]) => {
          localStorage.setItem(`fieldImageIndex_${key}`, index);
        });
      }


    } catch (e) {
      console.error("Ошибка при разборе сохранённого состояния:", e);
      alert("Не удалось загрузить сохранённое состояние — формат данных повреждён.");
    }
  }

  const savedRotations = localStorage.getItem('tokenRotations');
  if (savedRotations) {
    try {
      const rotations = JSON.parse(savedRotations);
      Object.entries(rotations).forEach(([key, value]) => {
        localStorage.setItem(key, value);
      });
    } catch (e) {
      console.error("Ошибка при разборе сохранённых поворотов:", e);
    }
  }

  //Восстанавливаем состояние чекбокса бонус жетонов
    const useBonusTokensCheckbox = document.getElementById('useBonusTokensCheckbox');
    if (useBonusTokensCheckbox) {
      const savedState = localStorage.getItem('useBonusTokens') === 'true';
      useBonusTokensCheckbox.checked = savedState;
      toggleBonusTokenVisibility();
    }

  document.querySelectorAll('.grid-cell').forEach(cell => {
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);

	  // Обновляем ячейку для всех слоёв
	  for (let layer = 1; layer <= 3; layer++) {
		updateCell(cell, row, col, layer);
	  }

  });


  validateLimits();
  updateTokenCounters();
  updateTokenStyles();
  updatePuzzleIconsDisplay();
}

document.getElementById('saveButton').addEventListener('click', () => {
  const container = document.querySelector('.main-grid-container');
  if (!container) {
    alert("Контейнер не найден.");
    return;
  }

  const levelNameInput = document.getElementById('levelNameInput');
  let levelName = levelNameInput?.value.trim();
  const fileName = levelName ? transliterate(levelName) + '.png' : 'bg_level.png';

  // === СКРЫВАЕМ ГРАНИЦЫ ЯЧЕЕК ДЛЯ ЧИСТОГО ИЗОБРАЖЕНИЯ ===
  const elementsToHideBorders = container.querySelectorAll('.grid-cell, #layer0 > div');
  const originalStyles = [];
  elementsToHideBorders.forEach(el => {
    originalStyles.push({ el, border: el.style.border });
    el.style.border = 'none';
  });

  function restoreStyles() {
    originalStyles.forEach(({ el, border }) => {
      el.style.border = border;
    });
  }

  const ImgScale = 2; // Коэффициент масштаба сохранения

  // === РЕНДЕРИМ КОНТЕЙНЕР В canvas ===
  html2canvas(container, {
    backgroundColor: null, // <<< Прозрачный фон
    scale: window.devicePixelRatio * ImgScale // Увеличиваем масштаб в 2 раза
  }).then(canvas => {
    // === НАХОДИМ МИН/МАКС ГРАНИЦЫ СЕТКИ (без белых краев) ===
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
    const step = 5;

    for (let y = 0; y < canvas.height; y += step) {
      for (let x = 0; x < canvas.width; x += step) {
        const index = (y * canvas.width + x) * 4;
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];
        const a = data[index + 3];

        if (a === 0) continue;

        const isWhite = (
          r > 250 && g > 250 && b > 250
        );

        if (!isWhite) {
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }

    if (minX > maxX || minY > maxY) {
      alert("Нет видимого содержимого для сохранения.");
      return Promise.reject("Нет содержимого");
    }

    const padding = 10;
    minX = Math.max(0, minX - padding);
    minY = Math.max(0, minY - padding);
    maxX = Math.min(canvas.width, maxX + padding);
    maxY = Math.min(canvas.height, maxY + padding);

    const width = maxX - minX;
    const height = maxY - minY;

    // === ОБРЕЗАЕМ ИЗОБРАЖЕНИЕ СЕТКИ ===
    const croppedCanvas = document.createElement('canvas');
    croppedCanvas.width = width;
    croppedCanvas.height = height;

    const croppedCtx = croppedCanvas.getContext('2d');
    croppedCtx.fillStyle = "rgba(0, 0, 0, 0)";
    croppedCtx.fillRect(0, 0, width, height);

    croppedCtx.drawImage(
      canvas,
      minX, minY, width, height,
      0, 0, width, height
    );

    return croppedCanvas;
  }).then(croppedCanvas => {
    let icons = [];
    const puzzlePanel = document.getElementById('puzzleIconsContainer');
    // Проверяем текущий режим: если это "level", то не включаем панель головоломок
    const editorMode = editorModeSwitcher.value;
    if (editorMode === 'puzzle') {
      const iconElements = puzzlePanel?.querySelectorAll('img.puzzle-icon') || [];
      icons = Array.from(iconElements);
    } else {
      icons = [];
    }


    if (!icons.length && editorMode !== 'puzzle') {
      // Если режим level и нет иконок, просто сохраняем игровое поле
      downloadImage(croppedCanvas, fileName);
      return;
    }

    // Размер сохраняемых иконок панели Головоломок, размер зазора и размер панели общий.
    const iconSize = 50 * ImgScale;
    const gap = 15 * ImgScale;
    const panelHeight = 50 * ImgScale;
    const totalWidth = icons.length * iconSize + (icons.length - 1) * gap;

    const iconCanvas = document.createElement('canvas');
    iconCanvas.width = totalWidth;
    iconCanvas.height = panelHeight;
    const iconCtx = iconCanvas.getContext('2d');

    const loadPromises = icons.map((icon, i) => {
      return new Promise(resolve => {
        const imgElement = icon;

        if (!imgElement || !imgElement.src || imgElement.src.includes('empty.png')) {
          resolve();
          return;
        }

        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = imgElement.src;

        img.onload = () => {
          iconCtx.drawImage(img, i * (iconSize + gap), 0, iconSize, iconSize);
          resolve();
        };

        img.onerror = (e) => {
          console.error("Ошибка загрузки иконки:", imgElement.src, e);
          resolve();
        };
      });
    });

    if (editorMode === 'puzzle' && icons.length > 0) {
      Promise.all(loadPromises).then(() => {
        combineCanvases(iconCanvas, croppedCanvas, fileName);
      });
    } else {
      // В режиме уровня или без иконок — сразу скачиваем игровое поле
      downloadImage(croppedCanvas, fileName);
    }

  }).catch(err => {
    console.error("Ошибка при сохранении:", err);
    alert("Произошла ошибка при сохранении изображения.");
  }).finally(() => {
    restoreStyles(); // Восстанавливаем стили границ
  });

  // === ФУНКЦИИ ===

  function combineCanvases(iconCanvas, gridCanvas, filename) {
    const padding = 20;

    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = Math.max(iconCanvas.width, gridCanvas.width);
    finalCanvas.height = iconCanvas.height + gridCanvas.height + padding;

    const finalCtx = finalCanvas.getContext('2d');

    // Прозрачный фон
    finalCtx.fillStyle = "rgba(0, 0, 0, 0)";
    finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

    // Центрируем панель головоломок по горизонтали
    const startX = (finalCanvas.width - iconCanvas.width) / 2;
    finalCtx.drawImage(iconCanvas, startX, 0); // <<< Панель головоломок сверху

    // Добавляем игровое поле ниже
    finalCtx.drawImage(gridCanvas, 0, iconCanvas.height + padding); // <<< Поле ниже панели

    // === ВРЕМЕННОЕ ПРЕДВАРИТЕЛЬНОЕ ОТОБРАЖЕНИЕ ===
    const outputDiv = document.getElementById('output');
    if (!outputDiv) {
      console.warn("Контейнер #output не найден");
      downloadImage(finalCanvas, filename);
      return;
    }

    outputDiv.innerHTML = ''; // очищаем предыдущее

    const previewImg = document.createElement('img');
    previewImg.src = finalCanvas.toDataURL('image/png');
    previewImg.style.maxWidth = '100%';
    previewImg.style.border = '1px solid #ccc';
    previewImg.style.marginBottom = '10px';

    const infoText = document.createElement('div');
    infoText.textContent = 'Подождите... Изображение будет сохранено через 3 секунды.';
    infoText.style.marginBottom = '10px';

    outputDiv.appendChild(previewImg);
    outputDiv.appendChild(infoText);

    // === СКАЧИВАНИЕ ИЗОБРАЖЕНИЯ ЧЕРЕЗ 3 СЕКУНДЫ ===
//    setTimeout(() => {
      const link = document.createElement('a');
      link.download = filename;
      link.href = finalCanvas.toDataURL('image/png');
      document.body.appendChild(link); // Firefox fix
      link.click();
      document.body.removeChild(link);

      // Очищаем превью после скачивания
      outputDiv.innerHTML = '';
//    }, 3000);
  }

  function downloadImage(canvas, filename) {
    const link = document.createElement('a');
    link.download = filename;
    link.href = canvas.toDataURL('image/png');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
});

// Очистка игрового поля
document.getElementById('clearButton').addEventListener('click', () => {
  if (confirm("Вы уверены, что хотите очистить уровень и начать заново? Вернуть уровень назад будет нельзя!")) {

    localStorage.clear();

    // === Очистка сетки ===
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 10; col++) {
        grid[row][col] = ['', '', ''];
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (cell) cell.innerHTML = '';
      }
    }

    // === Очистка пользовательских позиций полей ===
    Object.keys(userFieldPositions).forEach(key => delete userFieldPositions[key]);

    // === Восстанавливаем поле 4x4 по умолчанию ===
    const default4x4 = { row: 0, col: 3 };
    userFieldPositions["4x4"] = default4x4;
    
    // === Очистка названия и описания уровня ===
    const nameInput = document.getElementById('levelNameInput');
    const descriptionInput = document.getElementById('levelDescription');
    if (nameInput) nameInput.value = ''; // Очистка названия
    if (descriptionInput) descriptionInput.value = ''; // Очистка описания

    // === Сбрасываем чекбоксы ===
    document.querySelectorAll('[data-field]').forEach(cb => {
      cb.checked = cb.dataset.field === "4x4"; // Только 4x4 остаётся включённым
      cb.disabled = false; // Все доступны
    });

    // === Перерисовываем поля ===
    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

    // === Обновляем отображение ячеек ===
    document.querySelectorAll('.grid-cell').forEach(cell => {
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      updateCell(cell, row, col);
    });

    // === Сброс лимитов и стилей ===
    validateLimits();
    updateTokenCounters();
    updateTokenStyles();

    currentLayer = 1;
    const buttons = document.querySelectorAll('.layer-button');
    buttons.forEach(btn => btn.classList.remove('active'));
    buttons[1].classList.add('active'); // Слой 1

    // === Сохраняем чистое состояние ===
    saveStateToLocalStorage();
  }
});


function updateFieldCheckboxes() {
  const new1 = document.querySelector('input[data-field="4x2_1"]');
  const new2 = document.querySelector('input[data-field="4x2_2"]');
  const old1 = document.querySelector('input[data-field="2x4_1"]');
  const old2 = document.querySelector('input[data-field="2x4_2"]');

  if (new1.checked || new2.checked) {
    old1.checked = false;
    old2.checked = false;
    old1.disabled = true;
    old2.disabled = true;
  } else {
    old1.disabled = false;
    old2.disabled = false;
  }
}

document.querySelectorAll('.new-field').forEach(cb => {
  cb.addEventListener('change', () => {
    updateFieldCheckboxes();
    
    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

  });
});


// Пары взаимоисключающих полей
const mutuallyExclusivePairs = [
  ['2x4_1', '4x2_1'],
  ['2x4_2', '4x2_2']
];

function updateMutualExclusion() {
  mutuallyExclusivePairs.forEach(([key1, key2]) => {
    const cb1 = document.querySelector(`input[data-field="${key1}"]`);
    const cb2 = document.querySelector(`input[data-field="${key2}"]`);

    if (!cb1 || !cb2) return;

    // Если выбран первый — выключаем второй
    if (cb1.checked) {
      cb2.checked = false;
      cb2.disabled = true;
    }
    // Если выбран второй — выключаем первый
    else if (cb2.checked) {
      cb1.checked = false;
      cb1.disabled = true;
    }
    // Иначе оба доступны
    else {
      cb1.disabled = false;
      cb2.disabled = false;
    }
  });
}

// Привязываем к событиям изменения состояния чекбоксов
document.querySelectorAll('[data-field]').forEach(cb => {
  cb.addEventListener('change', () => {
    updateMutualExclusion();
    
    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

  });
});

// Вызываем при загрузке страницы
updateMutualExclusion();

// === Сохранение уровня в JSON с поворотами ===
document.getElementById('saveLevelButton').addEventListener('click', () => {
  const levelNameInput = document.getElementById('levelNameInput');
  let levelName = levelNameInput.value.trim();
  if (!levelName) {
    alert("Введите название уровня!");
    return;
  }
  const latinName = transliterate(levelName);

  // === Получаем текущее состояние редактора ===
  const mapEditorState = localStorage.getItem('mapEditorState');
  if (!mapEditorState) {
    alert("Нет данных для сохранения уровня.");
    return;
  }

  try {
    const loaded = JSON.parse(mapEditorState);

    // === Добавляем имя уровня ===
    loaded.name = levelName;

    // === Получаем повороты из localStorage ===
    const tokenRotations = localStorage.getItem('tokenRotations');
    if (tokenRotations) {
      try {
        loaded.rotations = JSON.parse(tokenRotations);
      } catch (e) {
        console.warn("Ошибка парсинга rotations:", e);
        loaded.rotations = {};
      }
    } else {
      loaded.rotations = {}; // если нет поворотов — всё равно добавляем пустой объект
    }

    // === Сохраняем в файл JSON ===
    const blob = new Blob([JSON.stringify(loaded, null, 2)], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${latinName}.json`;
    link.click();

    // === (Опционально) Сохраняем в localStorage под именем ===
    localStorage.setItem(`savedLevel_${latinName}`, JSON.stringify(loaded));

    alert(`Файл уровня "${levelName}.json" успешно сохранён.`);
  } catch (e) {
    console.error("Ошибка при подготовке уровня к сохранению:", e);
    alert("Не удалось сохранить уровень — произошла ошибка.");
  }
});


//Загрузка уровня из JSON
document.getElementById('loadLevelButton').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const loaded = JSON.parse(text);

      // === ШАГ 1: Загружаем данные в grid и другие переменные ===
      for (let r = 0; r < 10; r++) {
        for (let c = 0; c < 10; c++) {
          grid[r][c] = ['', '', ''];
        }
      }

      for (let r = 0; r < loaded.grid.length; r++) {
        for (let c = 0; c < loaded.grid[r].length; c++) {
          if (loaded.grid[r][c]) {
            grid[r][c] = [...loaded.grid[r][c]];
          }
        }
      }

      // Очистка и заполнение userFieldPositions
      Object.keys(userFieldPositions).forEach(key => delete userFieldPositions[key]);
      if (loaded.userFieldPositions) {
        Object.assign(userFieldPositions, loaded.userFieldPositions);
      }

      // Установка состояния чекбоксов
      document.querySelectorAll('[data-field]').forEach(cb => {
        const key = cb.dataset.field;
        cb.checked = loaded.checkboxes?.[key] ?? false;
      });

		// === ШАГ: Заполняем поля "Название уровня" и "Описание уровня" ===
		const nameInput = document.getElementById('levelNameInput');
		const descriptionInput = document.getElementById('levelDescription');

		if (nameInput) {
		  nameInput.value = loaded.name || '';
		}

		if (descriptionInput) {
		  descriptionInput.value = loaded.description || '';
		}

      // === ШАГ 2: Применяем повороты к токенам через localStorage или напрямую ===
      if (loaded.rotations && typeof loaded.rotations === 'object') {
        Object.entries(loaded.rotations).forEach(([key, value]) => {
          localStorage.setItem(key, value);
        });
        
        Object.keys(loaded.rotations).forEach(key => {
		});
      }

        const fieldImageIndices = {};
        document.querySelectorAll('.grid-field').forEach(img => {
          fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
        });
        drawGameFields(fieldImageIndices);

      // === ШАГ 3: Обновляем ячейки с учетом поворотов ===
      document.querySelectorAll('.grid-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        updateCell(cell, row, col);
      });

      validateLimits();
      updateTokenCounters();
      updateTokenStyles();

      // === ШАГ 4: Сохраняем всё в localStorage за один вызов ===
      saveStateToLocalStorage();

      alert(`Уровень "${loaded.name}" успешно загружен.`);

    } catch (e) {
      console.error("Ошибка при чтении JSON:", e);
      alert("Ошибка при загрузке уровня — неверный формат файла.");
    }
  };
  input.click();
});

// Обновление кэша каждые 7 дней
function shouldRefreshCache(timestampKey, maxAgeMs = 7 * 24 * 60 * 60 * 1000) {
  const lastCached = localStorage.getItem(timestampKey);
  return !lastCached || Date.now() - parseInt(lastCached) > maxAgeMs;
}

function cacheImageWithExpiry(url) {
  const timestampKey = `cached_image_timestamp_${url}`;
  const cachedUrlKey = `cached_image_${url}`;

  // Если кэш актуален — возвращаем его
  if (!shouldRefreshCache(timestampKey)) {
    const cached = localStorage.getItem(cachedUrlKey);
    if (cached) {
      return Promise.resolve(cached);
    }
  }

  // Загружаем новое изображение
  return fetch(url)
    .then(response => {
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return response.blob();
    })
    .then(blob => {
      const reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onload = () => {
          localStorage.setItem(cachedUrlKey, reader.result);
          localStorage.setItem(timestampKey, Date.now());
          resolve(reader.result);
        };
        reader.onerror = () => reject(new Error('FileReader error'));
        reader.readAsDataURL(blob);
      });
    })
    .catch(err => {
      console.warn(`Ошибка при загрузке "${url}"`, err);

      // Возвращаем старый кэш, если он есть
      const fallback = localStorage.getItem(cachedUrlKey);
      if (fallback) {
        console.log("Используется старый кэш вместо недоступного изображения");
        return fallback;
      }

      // Иначе — исходный URL
      return url;
    });
}

// Код для зоны корзины
const trashZone = document.getElementById('trashZone');

if (trashZone) {
  // Разрешаем браузеру реагировать на dragover (для поддержки drop)
  trashZone.addEventListener('dragover', e => {
    e.preventDefault();
    trashZone.style.backgroundColor = '#ffebee';
  });

  trashZone.addEventListener('dragleave', () => {
    trashZone.style.backgroundColor = '';
  });

  trashZone.addEventListener('drop', e => {
    e.preventDefault();
    trashZone.style.backgroundColor = '';
    const tokenName = e.dataTransfer.getData('text/plain');
    const fromRow = parseInt(e.dataTransfer.getData('from-row'));
    const fromCol = parseInt(e.dataTransfer.getData('from-col'));

    if (!isNaN(fromRow) && !isNaN(fromCol)) {
      grid[fromRow][fromCol][currentLayer - 1] = '';
      const cell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
      if (cell) {
        updateCell(cell, fromRow, fromCol);
      }
      validateLimits();
      updateTokenCounters();
      updateTokenStyles();
      saveStateToLocalStorage();
    }
  });
}

// === Обработчик чекбокса "Использовать жетоны краудфандинга" и функция их сокрытия
document.getElementById('useBonusTokensCheckbox').addEventListener('change', function () {
  const show = this.checked;

  // Скрываем/показываем элементы на панели
  document.querySelectorAll('.token-pair-wrapper').forEach(wrapper => {
    const isBonusPair = wrapper.querySelector('[data-pair-group="bonus-pair"]');
    const isArucoPair = wrapper.querySelector('[data-pair-group="aruco-pair"]');
    if (isBonusPair || isArucoPair) {
      wrapper.style.display = show ? 'inline-block' : 'none';
    }
  });

  // Скрываем/показываем токены на игровом поле
  document.querySelectorAll('.token').forEach(img => {
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName);
    if (token && (token.pairGroup === 'bonus-pair' || token.pairGroup === 'aruco-pair')) {
      img.style.visibility = show ? 'visible' : 'hidden';
    }
  });

  saveStateToLocalStorage();
});

function toggleBonusTokenVisibility() {
  const checkbox = document.getElementById('useBonusTokensCheckbox');
  const show = checkbox?.checked;
  document.querySelectorAll('.token-pair-wrapper').forEach(wrapper => {
    const isBonusPair = wrapper.querySelector('[data-pair-group="bonus-pair"]');
    const isArucoPair = wrapper.querySelector('[data-pair-group="aruco-pair"]');
    if (isBonusPair || isArucoPair) {
      wrapper.style.display = show ? 'inline-block' : 'none';
    }
  });
  document.querySelectorAll('.token').forEach(img => {
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName);
    if (token && (token.pairGroup === 'bonus-pair' || token.pairGroup === 'aruco-pair')) {
      img.style.visibility = show ? 'visible' : 'hidden';
    }
  });
}

const puzzleIconsContainer = document.getElementById('puzzleIconsContainer');

let selectedPuzzleIcons = ['', '', '', '', '']; // до 5 возможных значений

  function updatePuzzleIconsDisplay() {
    const icons = document.querySelectorAll('.puzzle-icon');
    icons.forEach((icon, index) => {
      const key = selectedPuzzleIcons[index];
      if (key) {
        const condition = puzzleConditions.find(c => c.key === key);
        if (condition) {
          icon.src = getCachedImageURL(condition.image);
          icon.alt = condition.key;
        }
      } else {
        icon.src = IMAGE_PREFIX + 'empty.png';
        icon.alt = '';
      }
    });
  }

function createPuzzleIcons() {
  puzzleIconsContainer.innerHTML = '';
  for (let i = 0; i < 5; i++) {
    const wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.textAlign = 'center';

    const icon = document.createElement('img');
    icon.src = IMAGE_PREFIX + 'empty.png'; // путь к прозрачному изображению или фону
    icon.alt = 'empty';
    icon.className = 'puzzle-icon';
    icon.dataset.index = i;

    icon.addEventListener('click', () => {
      cyclePuzzleIcon(icon);
    });

    const label = document.createElement('div');
    label.textContent = `#${i+1}`;
    label.style.fontSize = '10px';
    label.style.marginTop = '4px';

    wrapper.appendChild(icon);
    wrapper.appendChild(label);
    puzzleIconsContainer.appendChild(wrapper);
  }
}

  const puzzleSlots = {
    0: ['lvl1', 'lvl2', 'lvl3', 'lvl4', 'lvl5'], // #1: уровни сложности
    1: ['repeat2', 'condition', 'attack', 'defense', 'bot1', 'bot2'], // #2: бонусы и боты
    2: ['repeat2', 'condition', 'attack', 'defense', 'bot1', 'bot2'], // #3: бонусы и боты
    3: ['repeat2', 'condition', 'attack', 'defense', 'bot1', 'bot2'], // #4: бонусы и боты
    4: ['line1', 'line2', 'line3', 'line4', 'line5', 'line6', 'lineN'] // #5: линии программы
  };

  function cyclePuzzleIcon(icon) {
    const index = parseInt(icon.dataset.index);
    const currentKey = selectedPuzzleIcons[index];

    // Получаем допустимые значения из объекта
    const allowedKeys = puzzleSlots[index] || [];

    // Находим следующий подходящий ключ
    const currentIndex = allowedKeys.indexOf(currentKey);
    const nextIndex = (currentIndex + 1) % (allowedKeys.length + 1); // +1 для empty

    if (nextIndex === allowedKeys.length) {
      // empty
      icon.src = IMAGE_PREFIX + 'empty.png';
      icon.alt = '';
      icon.classList.remove('active');
      selectedPuzzleIcons[index] = '';
    } else {
      const condition = puzzleConditions.find(c => c.key === allowedKeys[nextIndex]);
      if (condition) {
        icon.src = getCachedImageURL(condition.image);
        icon.alt = condition.key;
        icon.classList.add('active');
        selectedPuzzleIcons[index] = condition.key;
      }
    }

    saveStateToLocalStorage();
  }

  const editorModeSwitcher = document.getElementById('editorModeSwitcher');
  const puzzlePanel = document.getElementById('puzzlePanelIcons');

  editorModeSwitcher.addEventListener('change', () => {
    const mode = editorModeSwitcher.value;
    if (mode === 'puzzle') {
      puzzlePanel.style.display = 'block';
    } else {
      puzzlePanel.style.display = 'none';
    }
    saveStateToLocalStorage();
  });

  // === Загрузка состояния режима при старте ===
  function loadEditorMode() {
    const savedState = localStorage.getItem('mapEditorState');
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState);
        if (parsedState.editorMode) {
          editorModeSwitcher.value = parsedState.editorMode;
          if (parsedState.editorMode === 'puzzle') {
            puzzlePanel.style.display = 'block';
          }
        }
      } catch (e) {
        console.error("Ошибка загрузки режима:", e);
      }
    }
  }


// При первой загрузке или при F5

// === Инициализация при загрузке страницы ===

loadStateFromLocalStorage(); // <-- загружаем из localStorage
toggleBonusTokenVisibility();
createPuzzleIcons();
updatePuzzleIconsDisplay();

    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

document.querySelectorAll('.grid-cell').forEach(cell => {
  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  updateCell(cell, row, col);
});

validateLimits();
updateTokenCounters();
updateTokenStyles();
toggleBonusTokenVisibility();
loadEditorMode();

</script>
</body>
</html>
