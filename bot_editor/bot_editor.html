<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Редактор программ для Ботов Битвы Големов v0.0.1</title>
  <meta http-equiv="Content-Language" content="ru">
  <meta name="google" content="notranslate">
<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }
    #blocklyDiv {
    position: absolute;
    top: 0;
    left: 10px;
    right: 10px;
    height: calc(90% - 80px);
    z-index: 1;
    }
  .button-container {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 1000;
  }
  .button-container button {
    padding: 8px 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  .button-container button:hover {
    background-color: #45a049;
  }

    #algorithmOutput {
    position: absolute;
    top: calc(90% - 80px); 
    left: 10px;
    right: 10px;
    height: 80px;
    min-height: 60px;
    max-height: 300px;
    overflow-y: auto;
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #333;
    white-space: pre;
    line-height: 1.4;
    z-index: 999;
    box-sizing: border-box;
    resize: vertical;
    cursor: ns-resize;
    text-align: left;
    }

    /* Добавляем "ручку" для ресайза сверху */
    #algorithmOutput::before {
    content: "";
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: #aaa;
    cursor: ns-resize;
    z-index: 1000;
    }

  /* --- Медиазапрос для мобильных устройств --- */
    @media (max-width: 768px) {
    
      .button-container button {
        padding: 12px 16px; /* Увеличены отступы кнопок */
        font-size: 16px; /* Увеличен шрифт кнопок */
      }

      /* Увеличиваем "ручку" для мобильных */
      #algorithmOutput::before {
        height: 10px; /* Увеличена высота "ручки" */
      }
      /* Стили для изменения размера на мобильных (сенсорный фидбэк) */
      #algorithmOutput.resizing {
        background-color: #e0e0e0; /* Визуальная обратная связь */
        border-color: #999;
      }
      #algorithmOutput::before:active {
        background: #888; /* Изменение цвета при активном ресайзе */
      }
      
      /* Увеличиваем инструкцию для сенсорного выбора */
      #selection-instruction {
          padding: 15px 25px !important; /* Увеличены отступы */
          border-radius: 8px !important; /* Более скругленные углы */
          font-size: 18px !important; /* Увеличен шрифт инструкции */
          box-shadow: 0 4px 15px rgba(0,0,0,0.3) !important;
      }
    }

</style>
  <script src="https://unpkg.com/blockly@12.2.0/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly@12.2.0/msg/ru.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/pdfmake.min.js" integrity="sha512-axXaF5grZBaYl7qiM6OMHgsgVXdSLxqq0w7F4CQxuFyrcPmn0JfnqsOtYHUun80g6mRRdvJDrTCyL8LQqBOt/Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/vfs_fonts.min.js" integrity="sha512-EFlschXPq/G5zunGPRSYqazR1CMKj0cQc8v6eMrQwybxgIbhsfoO5NAMQX3xFDQIbFlViv53o7Hy+yCWw6iZxA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://22176.hostkey.in:34172/pictures/bg_editor/html2canvas.min.js"></script>
</head>
<body>
  <div id="blocklyDiv"></div>
  <div class="button-container">
    <button id="saveButton">Сохранить Программу</button>
    <button id="loadButton">Загрузить Программу</button>
    <button id="newProgramButton">Новая программа</button>
    <button id="exportPdfButton">Экспорт в PDF</button>
    <button id="exportPngButton">Экспорт в PNG</button>
  </div>
  <div id="algorithmOutput">// Алгоритм будет здесь...</div>

<xml id="toolbox" style="display: none">
  <category name="Программа" colour="#FF8C00">
    <block type="bot_program"></block>
    <block type="bot_durability"></block>
    <block type="program_line_before"></block>
    <block type="program_line_1"></block>
    <block type="program_line_2"></block>
    <block type="program_line_3"></block>
    <block type="program_line_4"></block>
  </category>
  <category name="Движение" colour="#5599FF">
    <block type="move_forward"></block>
    <block type="move_backward"></block>
    <block type="turn_right"></block>
    <block type="turn_left"></block>
    <block type="stand_still"></block>
    <block type="throw_ai_dice"></block>
  </category>
  <category name="Действия" colour="#FF69B4">
    <block type="attack"></block>
    <block type="attack_force"></block>
    <block type="defend"></block>
    <block type="freeze"></block>
    <block type="jump"></block>
  </category>
  <category name="Циклы и Условия" colour="#FF8C00">
    <block type="custom_repeat"></block>
    <block type="custom_if"></block>
  </category>
  <category name="Условия" colour="#32CD32">
    <block type="enemy_present"></block>
    <block type="obstacle_present"></block>
    <block type="weather_condition"></block>
    <block type="damage_present"></block>
    <block type="water_hit"></block>
    <block type="can_attack"></block>
  </category>
</xml>

<script>
  // --- Перевод контекстного меню ---
  Blockly.Msg["DELETE_BLOCK"] = "Удалить блок";
  Blockly.Msg["DELETE_X_BLOCKS"] = "Удалить %1 блоков";
  Blockly.Msg["DUPLICATE_BLOCK"] = "Дублировать";
  Blockly.Msg["ADD_COMMENT"] = "Добавить комментарий";
  Blockly.Msg["REMOVE_COMMENT"] = "Удалить комментарий";
  Blockly.Msg["INLINE_INPUTS"] = "Встроенные входы";
  Blockly.Msg["EXTERNAL_INPUTS"] = "Внешние входы";
  Blockly.Msg["COLLAPSE_BLOCK"] = "Свернуть блок";
  Blockly.Msg["EXPAND_BLOCK"] = "Развернуть блок";
  Blockly.Msg["DISABLE_BLOCK"] = "Отключить блок";
  Blockly.Msg["ENABLE_BLOCK"] = "Включить блок";
  Blockly.Msg["HELP"] = "Помощь";

  // --- Определение блоков ---
  Blockly.defineBlocksWithJsonArray([
    {
      "type": "bot_program",
      "message0": "=== Программа для Бота: %1 ===",
      "args0": [{ "type": "field_input", "name": "PROGRAM_NAME", "text": "Имя Бота" }],
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "PROGRAM_LINES", "check": "ProgramLine" }],
      "colour": "#FF8C00",
      "tooltip": "Начальный блок программы бота. Можете задать Имя для Бота.",
      "previousStatement": null,
      "nextStatement": null
    },
    {
      "type": "bot_durability",
      "message0": "Прочность Бота %1 единиц Атаки",
      "args0": [{ "type": "field_dropdown", "name": "DURABILITY", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "previousStatement": "ProgramLine", 
      "nextStatement": "ProgramLine",
      "colour": "#32CD32",
      "tooltip": "Устанавливает прочность бота (количество единиц атаки, которые он может выдержать).",
      "helpUrl": ""
    },
    {
      "type": "program_line_before",
      "message0": "Программа исполняется в начале раунда",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "tooltip": "Программа Бота исполняется ПОСЛЕ выкладывания Программ игроков, но ДО начала раунда и открытия первой строки Программ.",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_1",
      "message0": "Перед строкой Программ игроков 1",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 1-й строки Программ игроков, но после начала раунда.",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_2",
      "message0": "Перед строкой Программ игроков 2",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 2-й строки Программ игроков, но после исполнения 1-й строки",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_3",
      "message0": "Перед строкой Программ игроков 3",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 3-й строки Программ игроков, но после исполнения 2-й строки",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_4",
      "message0": "Перед строкой Программ игроков 4",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 4-й строки Программ игроков, но после исполнения 3-й строки",
      "colour": "#FF8C00"
    },
    {
      "type": "move_forward",
      "message0": "Идти %1 шагов",
      "args0": [{ "type": "field_dropdown", "name": "STEPS", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Идти вперед на N клеток.",
      "colour": "#5599FF"
    },
    {
      "type": "move_backward",
      "message0": "Идти -%1 шагов",
      "args0": [{ "type": "field_dropdown", "name": "STEPS", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Идти назад на N клеток.",
      "colour": "#5599FF"
    },
    {
      "type": "turn_right",
      "message0": "Повернуть ↻ на %1 градусов",
      "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Повернуться на месте вправо на N градусов.",
      "colour": "#5599FF"
    },
    {
      "type": "turn_left",
      "message0": "Повернуть ↺ на %1 градусов",
      "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Повернуться на месте влево на N градусов.",
      "colour": "#5599FF"
    },
    {
      "type": "stand_still",
      "message0": "Ждать до <следующая команда>",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Ничего не делать до следующей команды или строки команд",
      "colour": "#5599FF"
    },
    {
      "type": "attack",
      "message0": "Атака на %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Атаковать клетку перед собой на N единиц урона.",
      "colour": "#FF69B4"
    },
    {
      "type": "attack_force",
      "message0": "Атака на %1 силой %2",
      "args0": [
        { "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] },
        { "type": "field_dropdown", "name": "POWER", "options": [["1","1"],["2","2"]] }
      ],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Атаковать на N клеток перед собой на M единиц урона.",
      "colour": "#FF69B4"
    },
    {
      "type": "defend",
      "message0": "Защита на %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Защита от Атак силой до N единиц Урона. Если Атакуют несколько противников, то N = N1 + N2 + N3 + N4",
      "colour": "#FF69B4"
    },
    {
      "type": "freeze",
      "message0": "Заморозить",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Заморозить клетку перед собой. Если на клетке Вода, то положить на нее жетон Льда.",
      "colour": "#FF69B4"
    },
    {
      "type": "jump",
      "message0": "Прыжок на %1 клетки",
      "args0": [
        {
          "type": "field_dropdown",
          "name": "DISTANCE",
          "options": [
            ["2", "2"],
            ["3", "3"]
          ]
        }
      ],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Прыгнуть на расстояние 2 или 3 клетки, если на них нет Бочки, Робота или Камня или запрыгнуть на 1-2 Бочки.",
      "colour": "#FF69B4"
    },
    {
      "type": "throw_ai_dice",
      "message0": "Кинь AI кубик",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Кинуть AI-кубик и выполнить выпавшую команду.",      
      "colour": "#5599FF"
    },
    {
      "type": "enemy_present",
      "message0": "Вижу противника на расстоянии %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "output": "Boolean",
      "tooltip": "Проверка, есть ли в поле зрения на N клетках перед роботом Противник (другой Робот).",   
      "colour": "#32CD32"
    },
    {
      "type": "obstacle_present",
      "message0": "Препятствие = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "tooltip": "Проверка, есть ли на клетке перед Роботом препятствие. См. инструкцию, какие жетоны или фигурки к ним относятся.", 
      "colour": "#32CD32"
    },
    {
      "type": "weather_condition",
      "message0": "Сторона поля = %1",
      "args0": [{ "type": "field_dropdown", "name": "CONDITION", "options": [["Лето","SUMMER"],["Зима","WINTER"]] }],
      "output": "Boolean",
      "tooltip": "Определить, поле на котором стоит Бот Летнее или Зимнее (с заносами и гололедом).", 
      "colour": "#32CD32"
    },
    {
      "type": "damage_present",
      "message0": "Есть повреждения бота = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "tooltip": "Определить, есть ли у Бота какие то повреждения. Учет повреждений вам нужно вести самостоятельно.", 
      "colour": "#32CD32"
    },
    {
      "type": "water_hit",
      "message0": "Впереди вода = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "tooltip": "Определить, есть ли перед Ботом Вода.", 
      "colour": "#32CD32"
    },
    {
      "type": "can_attack",
      "message0": "Можно в Атаку = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0", "FALSE"],["1", "TRUE"]]}],
      "output": "Boolean",
      "tooltip": "Определить, можно ли Атаковать клетку перед собой. Срабатывает, если там есть другой робот или препятствие, которое можно Атаковать.", 
      "colour": "#32CD32"
    },
    {
      "type": "custom_repeat",
      "message0": "Повторить %1 раз(а)",
      "args0": [{ "type": "field_number", "name": "TIMES", "value": 1, "min": 1, "max": 10 }],
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "DO", "check": "Action" }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Цикл повтора команд N раз (от 1 до 10)", 
      "colour": "#FF8C00"
    },
    {
      "type": "custom_if",
      "message0": "если %1 то %2",
      "args0": [
        { "type": "input_value", "name": "CONDITION", "check": "Boolean" },
        { "type": "input_statement", "name": "THEN", "check": "Action" }
      ],
      "message1": "иначе %1",
      "args1": [{ "type": "input_statement", "name": "ELSE", "check": "Action" }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "tooltip": "Условие если, то... иначе... Для срабатывания добавьте блоки из раздела Условия", 
      "colour": "#FF8C00"
    }
  ]);

    let workspace = null;
    const onresize = () => {
    const blocklyDiv = document.getElementById('blocklyDiv');
    const algorithmOutput = document.getElementById('algorithmOutput');
    const buttonAreaHeight = 60;
    const outputHeight = algorithmOutput.offsetHeight; // <- Использует текущую высоту
    const outputTop = algorithmOutput.offsetTop;       // <- Использует текущую позицию
    // Высота blocklyDiv = от верха до верха зоны алгоритма
    blocklyDiv.style.height = outputTop + 'px'; // <- Устанавливает высоту BlocklyDiv
    Blockly.svgResize(workspace);
    };

  // --- Функция для создания дефолтных блоков ---
  function createDefaultBlocks() {
    // Создаем корневой блок bot_program
    const rootBlock = workspace.newBlock('bot_program');
    rootBlock.getField('PROGRAM_NAME').setValue('Мой Бот');
    rootBlock.initSvg();
    rootBlock.render();

    // Создаем блок прочности
    const durabilityBlock = workspace.newBlock('bot_durability');
    durabilityBlock.initSvg();
    durabilityBlock.render();

    // Создаем первый блок строки программы (program_line_before)
    const line1 = workspace.newBlock('program_line_before');
    line1.initSvg();
    line1.render();

    // --- Исправленные соединения ---
    // 1. Подключаем блок прочности внутрь корневого блока через сокет PROGRAM_LINES
    //    Используем Blockly.Mutator.finishQueuedMutations для корректного подключения
    rootBlock.getInput('PROGRAM_LINES').connection.connect(durabilityBlock.previousConnection);

    // 2. Подключаем блок строки программы ПОСЛЕ блока прочности
    //    Используем nextConnection/previousConnection для последовательного соединения
    durabilityBlock.nextConnection.connect(line1.previousConnection);

    // Позиционируем корневой блок (остальные последуют за ним)
    rootBlock.moveBy(50, 50);
  }

  // --- Ограничение: только один экземпляр каждого program_line_* блока ---
  function enforceUniqueProgramLines() {
    const allowedTypes = ['program_line_before', 'program_line_1', 'program_line_2', 'program_line_3', 'program_line_4'];
    const usedTypes = new Set();

    const allBlocks = workspace.getAllBlocks(false);
    for (const block of allBlocks) {
      if (allowedTypes.includes(block.type)) {
        if (usedTypes.has(block.type)) {
          block.dispose(); // Удаляем дубликат
        } else {
          usedTypes.add(block.type);
        }
      }
    }
  }

  // --- Генератор JavaScript ---
  const javascriptGenerator = Blockly.JavaScript;

  // Генераторы (остаются без изменений)
  javascriptGenerator['bot_program'] = function(block) {
    const programName = block.getFieldValue('PROGRAM_NAME');
    const substack = javascriptGenerator.statementToCode(block, 'PROGRAM_LINES') || '';
    return `// === Программа Бота: ${programName} ===\n${substack}`;
  };

    javascriptGenerator['bot_durability'] = function(block) {
    const durability = block.getFieldValue('DURABILITY');
    // Предполагаем, что в скриптах бота будет функция setDurability
    return `setDurability(${durability});`;
  };

  ['program_line_before', 'program_line_1', 'program_line_2', 'program_line_3', 'program_line_4'].forEach((type, i) => {
    javascriptGenerator[type] = function(block) {
      const substack = javascriptGenerator.statementToCode(block, 'SUBSTACK') || '';
      return `// --- Строка Программы ${i+1} ---\n${substack}`;
    };
  });

  // Остальные генераторы (не меняем)
  javascriptGenerator['move_forward'] = (block) => `moveForward(${block.getFieldValue('STEPS')});\n`;
  javascriptGenerator['move_backward'] = (block) => `moveBackward(${block.getFieldValue('STEPS')});\n`;
  javascriptGenerator['turn_right'] = (block) => `turnRight(${block.getFieldValue('DEGREES')});\n`;
  javascriptGenerator['turn_left'] = (block) => `turnLeft(${block.getFieldValue('DEGREES')});\n`;
  javascriptGenerator['stand_still'] = () => `standStill();\n`;
  javascriptGenerator['attack'] = (block) => `attack(${block.getFieldValue('DISTANCE')});\n`;
  javascriptGenerator['attack_force'] = (block) => `attack(${block.getFieldValue('DISTANCE')}, ${block.getFieldValue('POWER')});\n`;
  javascriptGenerator['defend'] = (block) => `defend(${block.getFieldValue('DISTANCE')});\n`;
  javascriptGenerator['freeze'] = () => `freeze();\n`;
  javascriptGenerator['jump'] = (block) => {
    const distance = block.getFieldValue('DISTANCE');
    return `jump(${distance});
  `;
  };
  javascriptGenerator['throw_ai_dice'] = () => `throwAIDice();\n`;
  javascriptGenerator['custom_repeat'] = function(block) {
    const times = block.getFieldValue('TIMES');
    const doBlock = javascriptGenerator.statementToCode(block, 'DO') || '';
    return `repeat(${times}, function() {\n  ${doBlock}});\n`;
  };
  javascriptGenerator['custom_if'] = function(block) {
    const condition = javascriptGenerator.valueToCode(block, 'CONDITION', javascriptGenerator.ORDER_NONE) || 'false';
    const thenCode = javascriptGenerator.statementToCode(block, 'THEN') || '';
    const elseCode = javascriptGenerator.statementToCode(block, 'ELSE') || '';
    return `if (${condition}) {\n  ${thenCode}} else {\n  ${elseCode}\n}\n`;
  };

  // --- Генерация читаемого алгоритма ---
    function generateReadableAlgorithm() {
    const output = document.getElementById('algorithmOutput');
    const lines = [];

    function traverseBlock(block, indent = 0) {
        if (!block) return;
        const prefix = "  ".repeat(indent); // ← Теперь табуляция (Python style)
        let text = "";

        switch (block.type) {
        case 'bot_durability':
            text = `Прочность Бота ${block.getFieldValue('DURABILITY')} единиц Атаки`;
            break;
        case 'program_line_before':
            text = 'Программа Бота исполняется в начале раунда';
            break;
        case 'program_line_1':
            text = 'Перед 1-й строкой Программ игроков';
            break;
        case 'program_line_2':
            text = 'Перед 2-й строкой Программ игроков';
            break;
        case 'program_line_3':
            text = 'Перед 3-й строкой Программ игроков';
            break;
        case 'program_line_4':
            text = 'Перед 4-й строкой Программ игроков';
            break;
        case 'move_forward':
            text = `Вперед на ${block.getFieldValue('STEPS')} шагов`;
            break;
        case 'move_backward':
            text = `Назад на ${block.getFieldValue('STEPS')} шагов`;
            break;
        case 'turn_right':
            text = `Поворот Вправо на ${block.getFieldValue('DEGREES')} градусов`;
            break;
        case 'turn_left':
            text = `Поворот Влево на ${block.getFieldValue('DEGREES')} градусов`;
            break;
        case 'stand_still':
            text = `Стоять на месте`;
            break;
        case 'throw_ai_dice':
            text = `Кинуть AI кубик`;
            break;
        case 'attack':
            text = `Атака на ${block.getFieldValue('DISTANCE')} клеток`;
            break;
        case 'attack_force':
            text = `Атака на ${block.getFieldValue('DISTANCE')} клеток силой ${block.getFieldValue('POWER')}`;
            break;
        case 'defend':
            text = `Защита на ${block.getFieldValue('DISTANCE')}`;
            break;
        case 'freeze':
            text = `Заморозить`;
            break;
        case 'jump':
            text = `Прыжок на ${block.getFieldValue('DISTANCE')} клетки`;
            break;

        case 'custom_repeat':
            text = `Повторить ${block.getFieldValue('TIMES')} раз(а)`;
            lines.push(prefix + text);
            const doBlock = block.getInputTargetBlock('DO');
            if (doBlock) {
            traverseStack(doBlock, indent + 1); // ← +1 отступ для тела цикла
            }
            return; // ← не добавляем дальше

        case 'custom_if':
            const conditionBlock = block.getInputTargetBlock('CONDITION');
            let condText = "условие";
            if (conditionBlock) condText = describeCondition(conditionBlock);

            // "Если ... то"
            lines.push(prefix + `Если ${condText}, то`);

            const thenBlock = block.getInputTargetBlock('THEN');
            if (thenBlock) {
            traverseStack(thenBlock, indent + 1); // ← +1 для then
            }

            const elseBlock = block.getInputTargetBlock('ELSE');
            if (elseBlock) {
            lines.push(prefix + "иначе");
            traverseStack(elseBlock, indent + 1); // ← +1 для else
            }
            return; // ← не добавляем дальше

        default:
            text = block.type.replace(/_/g, ' ');
        }

        // Обычные блоки (не if, не repeat)
        lines.push(prefix + text);
    }

    function traverseStack(block, indent = 0) {
        while (block) {
        traverseBlock(block, indent); // ← передаём текущий отступ
        block = block.getNextBlock();
        }
    }

    function describeCondition(block) {
        switch (block.type) {
        case 'enemy_present':
            return `Вижу противника на расстоянии ${block.getFieldValue('DISTANCE')} клеток`;
        case 'obstacle_present':
            return `Препятствие = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'weather_condition':
            return `Сторона поля = ${block.getFieldValue('CONDITION')}`;
        case 'damage_present':
            return `Есть повреждения бота = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'water_hit':
            return `Впереди вода = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'can_attack':
            return `Можно в Атаку = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        default:
            return "условие";
        }
    }

    const root = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
            let durabilityLine = "";

    if (root) {
        lines.push(`=== Программа для Бота: ${root.getFieldValue('PROGRAM_NAME')} ===`);

        // --- Новый способ поиска и обработки bot_durability ---
        // Ищем следующий блок после bot_program, который может быть bot_durability
        const nextBlock = root.getNextBlock(); // Получаем блок, подключенный к nextStatement

        if (nextBlock && nextBlock.type === 'bot_durability') {
            // Если следующий блок - это блок прочности, получаем значение
            const durabilityValue = nextBlock.getFieldValue('DURABILITY');
            durabilityLine = `Прочность Бота ${durabilityValue} единиц Атаки`;
        }
        lines.push(durabilityLine); // Добавляем строку о прочности

        // Обрабатываем строки программы (PROGRAM_LINES)
        const firstLine = root.getInputTargetBlock('PROGRAM_LINES');
        if (firstLine) {
            let currentLine = firstLine;
            while (currentLine) {
                traverseBlock(currentLine, 0);
                const substack = currentLine.getInputTargetBlock('SUBSTACK');
                if (substack) {
                    traverseStack(substack, 1);
                }
                currentLine = currentLine.getNextBlock();
            }
        }
    }


    output.textContent = lines.length > 0 ? lines.join('\n') : "// Алгоритм пуст";
    }


window.addEventListener('load', () => {
  workspace = Blockly.inject('blocklyDiv', {
    toolbox: document.getElementById('toolbox'),
    scrollbars: true,
    trashcan: true,
    zoom: { controls: true, wheel: true },
    startScale: 0.8
  });

    // Инициализация позиции
    const initialAlgorithmHeight = 80;
    const defaultAlgorithmHeight = initialAlgorithmHeight;
    algorithmOutput.style.height = initialAlgorithmHeight + 'px';
    algorithmOutput.style.top = `calc(100vh - ${initialAlgorithmHeight + 60}px)`;

    // Ресайз за верхний край
    let isResizing = false;
    algorithmOutput.addEventListener('mousedown', function(e) {
    const rect = algorithmOutput.getBoundingClientRect();
    if (e.clientY >= rect.top && e.clientY <= rect.top + 10) {
        isResizing = true;
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }
    });
    document.addEventListener('mousemove', function(e) {
    if (!isResizing) return;
    const newHeight = window.innerHeight - e.clientY - 60;
    if (newHeight >= 60 && newHeight <= 300) {
        algorithmOutput.style.height = newHeight + 'px';
        algorithmOutput.style.top = `calc(100vh - ${newHeight + 60}px)`;
        onresize();
        saveToStorage();
    }
    });
    document.addEventListener('mouseup', () => {
    isResizing = false;
    document.body.style.cursor = 'default';
    });

    let startY, startHeight;

    // Используем pointer события для лучшей поддержки сенсорных экранов и мыши
    algorithmOutput.addEventListener('pointerdown', function(e) {
        const rect = algorithmOutput.getBoundingClientRect();
        // Проверяем, что клик был на "ручке" (верхняя часть, высотой 10px)
        if (e.clientY >= rect.top && e.clientY <= rect.top + 10) {
            isResizing = true;
            startY = e.clientY;
            startHeight = parseInt(document.defaultView.getComputedStyle(algorithmOutput).height, 10);
            document.body.style.cursor = 'ns-resize';
            algorithmOutput.classList.add('resizing'); // Добавляем класс для визуального фидбэка
            e.preventDefault(); // Предотвращаем выделение текста и т.д.
            e.stopPropagation();
        }
    });

    document.addEventListener('pointermove', function(e) {
        if (!isResizing) return;
        const dy = e.clientY - startY; // Разница по Y
        const newHeight = startHeight - dy; // Новая высота (учитываем, что тянем вверх/вниз)
        
        // Ограничиваем минимальную и максимальную высоту
        if (newHeight >= 60 && newHeight <= 300) {
            algorithmOutput.style.height = newHeight + 'px';
            // Пересчитываем позицию top, так как высота изменилась
            algorithmOutput.style.top = `calc(100vh - ${newHeight + 60}px)`; 
            onresize(); // Пересчитываем размер BlocklyDiv
            saveToStorage(); // Сохраняем новую высоту
        }
        e.preventDefault(); // Предотвращаем прокрутку страницы во время ресайза
        e.stopPropagation();
    });

    document.addEventListener('pointerup', function(e) {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
            algorithmOutput.classList.remove('resizing'); // Убираем класс
            e.stopPropagation();
        }
    });

    // На случай, если указатель вышел за пределы документа
    document.addEventListener('pointercancel', function() {
         if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
            algorithmOutput.classList.remove('resizing');
        }
    });

  // --- Вспомогательные функции для работы с XML ---
  // В новых версиях Blockly используем Blockly.utils.xml
  const textToDom = function(text) {
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'text/xml');
    return xml.documentElement;
  };

  const domToText = function(dom) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(dom);
  };

  // --- Сохранение в localStorage ---
    const saveToStorage = () => {
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = domToText(xml);
    // Получаем текущую высоту зоны алгоритма
    const currentAlgorithmHeight = parseInt(algorithmOutput.style.height, 10) || defaultAlgorithmHeight;
    localStorage.setItem('blocklyWorkspace', JSON.stringify({
        xml: xmlText,
        scale: workspace.scale,
        scrollX: workspace.scrollX,
        scrollY: workspace.scrollY,
        algorithmHeight: currentAlgorithmHeight // Сохраняем высоту
    }));
    };

  // --- Загрузка из localStorage ---
  const loadFromStorage = () => {
    const savedData = localStorage.getItem('blocklyWorkspace');
    if (!savedData) return false;

    try {
      const state = JSON.parse(savedData);
      const xml = textToDom(state.xml);
      workspace.clear();
      Blockly.Xml.domToWorkspace(xml, workspace);

      if (state.scale) workspace.setScale(state.scale);
      if (state.scrollX !== undefined && state.scrollY !== undefined) {
        workspace.scroll(state.scrollX, state.scrollY);
      }

    // --- Загрузка сохранённой высоты зоны алгоритма ---
    if (state.algorithmHeight !== undefined) {
      const loadedHeight = Math.max(60, Math.min(300, state.algorithmHeight)); // Ограничиваем диапазон
      algorithmOutput.style.height = loadedHeight + 'px';
      algorithmOutput.style.top = `calc(100vh - ${loadedHeight + 60}px)`;
    }

      enforceUniqueProgramLines();
      generateReadableAlgorithm();
      return true;
    } catch (e) {
      console.error('Ошибка при загрузке из localStorage:', e);
      return false;
    }
  };

  // --- Обработчик изменений ---
  workspace.addChangeListener((event) => {
    if (event.type === Blockly.Events.UI) return;
    enforceUniqueProgramLines();
    generateReadableAlgorithm();
    saveToStorage();
  });

  // --- Загрузка из localStorage при старте (если есть данные) ---
  const loaded = loadFromStorage();

  // Если ничего не загружено — workspace остаётся пустым
  if (!loaded) {
    // Не создаём дефолтные блоки автоматически
    generateReadableAlgorithm(); // Покажет "Алгоритм пуст"
  }

  // --- Кнопка "Сохранить в файл" (.bot) ---
  document.getElementById('saveButton').onclick = function () {
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = domToText(xml);

    // --- Получение имени бота из корневого блока ---
    let fileNameBase = "Программа для бота"; // Значение по умолчанию
    const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
    if (rootBlock) {
      const botName = rootBlock.getFieldValue('PROGRAM_NAME')?.trim();
      if (botName) {
        // Заменяем недопустимые символы для имени файла
        fileNameBase = `Программа для бота ${botName}`.replace(/[/\\?%*:|"<>]/g, '_');
      }
    }
    const fileName = `${fileNameBase}.bot`;
    // ---------------------------------------------

    const blob = new Blob([xmlText], { type: 'text/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName; // Используем динамическое имя файла
    a.click();
    URL.revokeObjectURL(url);
    // Сохраняем и в localStorage
    saveToStorage();
    // Обновляем сообщение об успешном сохранении с новым именем файла
    alert(`Программа сохранена в файл "${fileName}"`); 
  };

  // --- Кнопка "Загрузить из файла" ---
  document.getElementById('loadButton').onclick = function () {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.bot,.xml,.txt';

    input.onchange = function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const xmlText = e.target.result;
        try {
          const xml = textToDom(xmlText);
          // Проверим, что это действительно XML и есть нужные теги
          if (xml.tagName !== 'xml') {
            throw new Error('Файл не содержит корректный XML для Blockly');
          }

          workspace.clear();
          Blockly.Xml.domToWorkspace(xml, workspace);

          // Сохраняем в localStorage после загрузки
          saveToStorage();
          alert('Программа успешно загружена из файла!');
        } catch (err) {
          alert('Ошибка при загрузке файла: ' + err.message);
          console.error(err);
        }
      };
      reader.readAsText(file);
    };

    input.click();
  };

    // --- Кнопка "Новая программа" --- // <-- Добавьте этот блок
    document.getElementById('newProgramButton').onclick = function () {
    if (workspace.getAllBlocks(false).length > 0 &&
        !confirm('Текущая программа будет заменена. Продолжить?')) {
        return;
    }
    workspace.clear();
    createDefaultBlocks(); 
    saveToStorage();       
    generateReadableAlgorithm(); 

    // --- Сброс высоты зоны алгоритма на стандартную ---
    algorithmOutput.style.height = defaultAlgorithmHeight + 'px';
    algorithmOutput.style.top = `calc(100vh - ${defaultAlgorithmHeight + 60}px)`;
    onresize(); // Пересчитываем размеры BlocklyDiv
    // ----------------------------------------------------

    alert('Создана новая программа по умолчанию.');
    };

  // --- Обработка изменения размера ---
  window.addEventListener('resize', onresize, false);
  onresize();
});


async function selectAreaAndCapture() {
    return new Promise((resolve, reject) => {
        const blocklyDiv = document.getElementById('blocklyDiv');
        if (!blocklyDiv) {
            reject(new Error('Элемент blocklyDiv не найден.'));
            return;
        }
        const blocklyRect = blocklyDiv.getBoundingClientRect();

        // --- Создаем UI элементы ---
        const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
        const toolboxWasVisible = toolbox && toolbox.style.display !== 'none';
        if (toolbox) toolbox.style.display = 'none';

        const isolationOverlay = document.createElement('div');
        isolationOverlay.id = 'isolation-overlay';
        isolationOverlay.style.cssText = `
            position: fixed;
            left: ${blocklyRect.left}px;
            top: ${blocklyRect.top}px;
            width: ${blocklyRect.width}px;
            height: ${blocklyRect.height}px;
            background-color: rgba(0, 0, 0, 0.01); /* Почти прозрачный, но не совсем, чтобы получать события */
            z-index: 99998;
            cursor: crosshair;
            touch-action: none; /* Критично для touch устройств: предотвращает стандартные жесты (scroll, zoom) */
        `;
        document.body.appendChild(isolationOverlay);

        const selectionOverlay = document.createElement('div');
        selectionOverlay.id = 'selection-overlay';
        selectionOverlay.style.cssText = `
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 0, 123, 0.1);
            pointer-events: none; /* Не мешает событиям проходить через него */
            z-index: 99999;
            display: none;
            left: 0;
            top: 0;
        `;
        isolationOverlay.appendChild(selectionOverlay);

        const instruction = document.createElement('div');
        instruction.id = 'selection-instruction';
        instruction.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007bff;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 100000;
            font-family: Arial, sans-serif;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none; /* Не мешает событиям */
            text-align: center;
        `;
        instruction.textContent = 'Обведите область с блоками: коснитесь и переместите, затем отпустите';
        document.body.appendChild(instruction);

        let isSelecting = false;
        let startX, startY;

        // --- Вспомогательные функции для получения координат ---
        // Универсальная функция для извлечения координат из событий мыши, касания или указателя
        const getEventCoordinates = (e) => {
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                // Touch Event
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                // Touch End/Cancel Event
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                // Mouse or Pointer Event
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return { clientX, clientY };
        };

        // --- Объявляем обработчики ---
        const startSelection = (e) => {
            // console.log("startSelection вызван", e.type); // Для отладки
            // Игнорировать клики правой/средней кнопкой мыши
            if (e.type === 'pointerdown' && e.button !== undefined && e.button !== 0) return;
            if (e.type === 'mousedown' && e.button !== 0) return;

            const coords = getEventCoordinates(e);
            isSelecting = true;
            startX = coords.clientX - blocklyRect.left;
            startY = coords.clientY - blocklyRect.top;
            
            selectionOverlay.style.display = 'block';
            selectionOverlay.style.left = startX + 'px';
            selectionOverlay.style.top = startY + 'px';
            selectionOverlay.style.width = '0px';
            selectionOverlay.style.height = '0px';
            
            e.preventDefault();
            e.stopPropagation();
        };

        const updateSelection = (e) => {
            // console.log("updateSelection вызван", e.type); // Для отладки
            if (!isSelecting) return;

            const coords = getEventCoordinates(e);
            const currentX = coords.clientX - blocklyRect.left;
            const currentY = coords.clientY - blocklyRect.top;

            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);

            selectionOverlay.style.width = width + 'px';
            selectionOverlay.style.height = height + 'px';
            selectionOverlay.style.left = Math.min(startX, currentX) + 'px';
            selectionOverlay.style.top = Math.min(startY, currentY) + 'px';
            
            e.preventDefault();
            e.stopPropagation();
        };

        // Функция очистки UI и восстановления Blockly
        const cleanupAndRestore = () => {
            // console.log("cleanupAndRestore вызван"); // Для отладки
            // --- Восстанавливаем Blockly ---
            const blocklyWorkspace = Blockly.getMainWorkspace();
            if (blocklyDiv) {
                blocklyDiv.style.pointerEvents = originalBlocklyPointerEvents;
            }
            if (blocklyWorkspace) {
                 blocklyWorkspace.onMouseDown_ = originalMouseDown;
                 blocklyWorkspace.onMouseMove_ = originalMouseMove;
                 blocklyWorkspace.onMouseUp_ = originalMouseUp;
                 blocklyWorkspace.onTouchStart_ = originalTouchStart;
                 blocklyWorkspace.onTouchMove_ = originalTouchMove;
                 blocklyWorkspace.onTouchEnd_ = originalTouchEnd;
                 blocklyWorkspace.onPointerDown_ = originalPointerDown;
                 blocklyWorkspace.onPointerMove_ = originalPointerMove;
                 blocklyWorkspace.onPointerUp_ = originalPointerUp;
            }
            if (toolbox && toolboxWasVisible) {
                toolbox.style.display = '';
            }

            // --- Удаление элементов интерфейса выбора ---
            const elementsToRemove = [
                document.getElementById('isolation-overlay'),
                document.getElementById('selection-overlay'),
                document.getElementById('selection-instruction')
            ];
            elementsToRemove.forEach(el => { if (el) el.remove(); });

            // --- Убираем ВСЕ обработчики событий ---
            const removeListeners = () => {
                // Pointer Events
                isolationOverlay.removeEventListener('pointerdown', startSelection);
                isolationOverlay.removeEventListener('pointermove', updateSelection);
                isolationOverlay.removeEventListener('pointerup', endSelection);
                isolationOverlay.removeEventListener('pointercancel', cancelSelection);
                document.removeEventListener('pointerup', endSelection);
                document.removeEventListener('pointercancel', cancelSelection);

                // Touch Events
                isolationOverlay.removeEventListener('touchstart', startSelection); // passive по умолчанию false для pointer/touch внутри touch-action: none
                isolationOverlay.removeEventListener('touchmove', updateSelection);
                isolationOverlay.removeEventListener('touchend', endSelection);
                isolationOverlay.removeEventListener('touchcancel', cancelSelection);
                document.removeEventListener('touchend', endSelection);
                document.removeEventListener('touchcancel', cancelSelection);

                // Mouse Events
                isolationOverlay.removeEventListener('mousedown', startSelection);
                isolationOverlay.removeEventListener('mousemove', updateSelection);
                isolationOverlay.removeEventListener('mouseup', endSelection);
                document.removeEventListener('mouseup', endSelection);
                document.removeEventListener('mousemove', updateSelection);
            };
            removeListeners();
        };

        const cancelSelection = (e) => {
             // console.log("cancelSelection вызван", e.type); // Для отладки
            if (!isSelecting) return;
            isSelecting = false;
            cleanupAndRestore();
            reject(new Error('Выделение области было прервано.'));
        };

        const endSelection = async (e) => {
             // console.log("endSelection вызван", e.type); // Для отладки
            if (!isSelecting) return;
            isSelecting = false;

            const coords = getEventCoordinates(e);
            const endX = coords.clientX - blocklyRect.left;
            const endY = coords.clientY - blocklyRect.top;

            const rect = {
                x: Math.min(startX, endX) + blocklyRect.left,
                y: Math.min(startY, endY) + blocklyRect.top,
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };

            // Всегда сначала чистим, чтобы UI исчез до долгой операции html2canvas
            cleanupAndRestore(); 

            if (rect.width < 10 || rect.height < 10) {
                console.warn('Область слишком мала. Экспорт отменён.');
                alert('Область слишком мала. Попробуйте снова.');
                reject(new Error('Область слишком мала.'));
                return;
            }

            try {
                console.log("Попытка захвата области на document.body:", rect);
                let canvas = await html2canvas(document.body, {
                    useCORS: true,
                    logging: false,
                    scale: 2,
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    backgroundColor: "#ffffff",
                });
                console.log("html2canvas успешно завершена, canvas получен:", canvas);
                canvas = trimCanvas(canvas);
                resolve(canvas);
            } catch (canvasError) {
                console.error("Ошибка внутри html2canvas или при её вызове:", canvasError);
                reject(canvasError);
            }
        };

        // --- Сохраняем оригинальные состояния Blockly перед отключением ---
        const originalBlocklyPointerEvents = blocklyDiv.style.pointerEvents || '';
        const blocklyWorkspace = Blockly.getMainWorkspace();
        
        const originalMouseDown = blocklyWorkspace ? blocklyWorkspace.onMouseDown_ : null;
        const originalMouseMove = blocklyWorkspace ? blocklyWorkspace.onMouseMove_ : null;
        const originalMouseUp = blocklyWorkspace ? blocklyWorkspace.onMouseUp_ : null;
        
        const originalTouchStart = blocklyWorkspace ? blocklyWorkspace.onTouchStart_ : null;
        const originalTouchMove = blocklyWorkspace ? blocklyWorkspace.onTouchMove_ : null;
        const originalTouchEnd = blocklyWorkspace ? blocklyWorkspace.onTouchEnd_ : null;
        
        const originalPointerDown = blocklyWorkspace ? blocklyWorkspace.onPointerDown_ : null;
        const originalPointerMove = blocklyWorkspace ? blocklyWorkspace.onPointerMove_ : null;
        const originalPointerUp = blocklyWorkspace ? blocklyWorkspace.onPointerUp_ : null;

        // --- Отключаем все взаимодействия с Blockly ---
        blocklyDiv.style.pointerEvents = 'none';
        if (blocklyWorkspace) {
            blocklyWorkspace.onMouseDown_ = null;
            blocklyWorkspace.onMouseMove_ = null;
            blocklyWorkspace.onMouseUp_ = null;
            blocklyWorkspace.onTouchStart_ = null;
            blocklyWorkspace.onTouchMove_ = null;
            blocklyWorkspace.onTouchEnd_ = null;
            blocklyWorkspace.onPointerDown_ = null;
            blocklyWorkspace.onPointerMove_ = null;
            blocklyWorkspace.onPointerUp_ = null;
        }

        // --- Добавляем обработчики Pointer Events (рекомендуемый современный способ) ---
        // Pointer Events охватывают мышь, касания и стилусы
        isolationOverlay.addEventListener('pointerdown', startSelection);
        isolationOverlay.addEventListener('pointermove', updateSelection);
        isolationOverlay.addEventListener('pointerup', endSelection);
        isolationOverlay.addEventListener('pointercancel', cancelSelection); // На случай прерывания (например, уведомление)

        // Также добавляем на document для надежности, если указатель вышел за пределы оверлея
        document.addEventListener('pointerup', endSelection);
        document.addEventListener('pointercancel', cancelSelection);

        // --- Добавляем обработчики Touch Events (для совместимости и явного контроля) ---
        // Хотя pointer events должны покрывать touch, явное добавление может помочь.
        // Важно: isolationOverlay.style.touchAction = 'none' делает passive: false необязательным для touchmove
        isolationOverlay.addEventListener('touchstart', startSelection); // passive по умолчанию false внутри touch-action: none
        isolationOverlay.addEventListener('touchmove', updateSelection); // passive по умолчанию false внутри touch-action: none
        isolationOverlay.addEventListener('touchend', endSelection);
        isolationOverlay.addEventListener('touchcancel', cancelSelection);

        // Добавляем на document на случай, если палец вышел за пределы оверлея
        document.addEventListener('touchend', endSelection);
        document.addEventListener('touchcancel', cancelSelection);

        // --- Добавляем обработчики Mouse Events (для совместимости с мышью) ---
        isolationOverlay.addEventListener('mousedown', startSelection);
        isolationOverlay.addEventListener('mousemove', updateSelection);
        isolationOverlay.addEventListener('mouseup', endSelection);
        
        // Добавляем на document для надежности
        document.addEventListener('mouseup', endSelection); 
        document.addEventListener('mousemove', updateSelection);

    });
}

// --- Исправленный обработчик onclick для экспорта в PDF ---
document.getElementById('exportPdfButton').onclick = async function () {
    try {
        if (typeof pdfMake === 'undefined' || typeof pdfMake.createPdf === 'undefined') {
            throw new Error('Библиотека pdfmake не загружена. Проверьте подключение скриптов.');
        }
        if (typeof html2canvas === 'undefined') {
            throw new Error('Библиотека html2canvas не загружена');
        }

        // --- Получаем текст алгоритма ---
        const algorithmOutputElement = document.getElementById('algorithmOutput');
        const algorithmText = algorithmOutputElement.textContent?.trim() || "// Алгоритм пуст или не сгенерирован.";

        // --- Получаем название программы ---
        let programNameFull = "=== Программа для Бота: Мой Бот ===";
        let algorithmLinesArray = [];
        if (algorithmText) {
            algorithmLinesArray = algorithmText.split('\n'); // Исправлено: split('\n')
            if (algorithmLinesArray.length > 0 && algorithmLinesArray[0].startsWith("===")) {
                programNameFull = algorithmLinesArray[0];
                algorithmLinesArray = algorithmLinesArray.slice(1);
            } else {
                const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
                const botName = rootBlock ? (rootBlock.getFieldValue('PROGRAM_NAME')?.trim() || "Мой Бот") : "Мой Бот";
                programNameFull = `=== Программа для Бота: ${botName} ===`;
            }
        }

        // --- Вызываем общую функцию выделения ---
        const canvas = await selectAreaAndCapture();
        const imgData = canvas.toDataURL('image/png');

        // --- Формируем документ для pdfmake ---
        const docDefinition = {
            content: [
                { text: programNameFull, style: 'header', alignment: 'center' },
                {
                    image: imgData,
                    fit: [500, 700],
                    alignment: 'center',
                    margin: [0, 15, 0, 25]
                },
                { text: 'Алгоритм программы:', style: 'subheader' },
                {
                    stack: algorithmLinesArray.map(line => ({
                        text: line,
                        style: 'algorithm',
                        preserveLeadingSpaces: true
                    })),
                    margin: [0, 5, 0, 0]
                }
            ],
            styles: {
                header: { fontSize: 18, bold: true, margin: [0, 0, 0, 10] },
                subheader: { fontSize: 14, bold: true, margin: [0, 10, 0, 5] },
                algorithm: { fontSize: 11, lineHeight: 1.3 }
            }
        };

        // --- Генерируем и скачиваем PDF ---
        let fileName = "Программа для Бота";
        const match = programNameFull.match(/=== Программа для Бота: (.+?) ===/);
        if (match && match[1]) {
            fileName = "Программа для Бота " + match[1].replace(/[^a-zA-Z0-9а-яА-ЯёЁ_\- ]/g, '_');
        } else {
            const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
            const botName = rootBlock ? (rootBlock.getFieldValue('PROGRAM_NAME')?.trim() || "Мой Бот") : "Мой Бот";
            fileName = "Программа для Бота " + botName;
        }
        pdfMake.createPdf(docDefinition).download(fileName + '.pdf');

    } catch (error) {
        console.error("Ошибка при экспорте в PDF:", error);

        // --- Улучшенная попытка восстановления ---
        try {
             // Вызываем общую функцию очистки, если она была создана
             // Поскольку selectAreaAndCapture завершилась с ошибкой до создания cleanupAndRestore,
             // мы повторяем логику очистки здесь, но более безопасно.
             const blocklyDiv = document.getElementById('blocklyDiv');
             if(blocklyDiv) blocklyDiv.style.pointerEvents = ''; // Восстанавливаем базовое взаимодействие

             const blocklyWorkspace = Blockly.getMainWorkspace();
             // Лучше было бы сохранять их в замыкании внутри selectAreaAndCapture,
             // но мы можем попытаться восстановить некоторые стандартные обработчики.
             // Однако, это не идеально. Лучше использовать cleanupAndRestore внутри selectAreaAndCapture.

             const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
             if (toolbox) toolbox.style.display = '';

             // Удаляем вспомогательные элементы, если они остались
             const overlayElement = document.getElementById('selection-overlay');
             const instructionElement = document.getElementById('selection-instruction');
             const isolationElement = document.getElementById('isolation-overlay');
             if (overlayElement) overlayElement.remove();
             if (instructionElement) instructionElement.remove();
             if (isolationElement) isolationElement.remove();

             // Пытаемся удалить обработчики, если они были добавлены
             // Поскольку ссылки не в области видимости, используем анонимные функции или универсальный способ
             // Это не идеально, но может помочь в некоторых случаях.
             // Лучше всего, чтобы cleanupAndRestore вызывалась внутри selectAreaAndCapture.
             // document.removeEventListener('mousedown', startSelection); // startSelection не определен здесь
             // document.removeEventListener('mousemove', updateSelection); // updateSelection не определен здесь
             // document.removeEventListener('mouseup', endSelection); // endSelection не определен здесь

             // Вместо этого, можно просто попробовать удалить все возможные обработчики
             // с известными именами функций, которые могли быть добавлены.
             // Но это не гарантирует полной очистки.

        } catch (restoreError) {
            console.warn("Ошибка при восстановлении интерфейса после ошибки PDF:", restoreError);
        }

        alert(`Ошибка экспорта в PDF: ${error.message}\nПроверьте консоль браузера для деталей.`);
    }
};

// --- Исправленный обработчик onclick для экспорта в PNG ---
document.getElementById('exportPngButton').onclick = async function () {
    try {
        if (typeof html2canvas === 'undefined') {
            throw new Error('Библиотека html2canvas не загружена');
        }

        // --- Получаем название программы для имени файла ---
        let fileNameBase = "Программа для бота";
        const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
        if (rootBlock) {
            const botName = rootBlock.getFieldValue('PROGRAM_NAME')?.trim();
            if (botName) {
                fileNameBase = `Программа для бота ${botName}`.replace(/[/\\?%*:|"<>]/g, '_');
            }
        }
        const fileName = `${fileNameBase}.png`;

        // --- Вызываем общую функцию выделения ---
        const canvas = await selectAreaAndCapture();

        // --- Создаем ссылку для скачивания ---
        const link = document.createElement('a');
        link.download = fileName;
        link.href = canvas.toDataURL('image/png');
        link.click();
        alert(`Изображение сохранено как "${fileName}"`);

    } catch (error) {
        console.error("Ошибка при экспорте в PNG:", error);

        // --- Улучшенная попытка восстановления ---
        try {
            const blocklyDiv = document.getElementById('blocklyDiv');
            if(blocklyDiv) blocklyDiv.style.pointerEvents = '';

            const blocklyWorkspace = Blockly.getMainWorkspace();
            // Попытка восстановления обработчиков (аналогично PDF)

            const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
            if (toolbox) toolbox.style.display = '';

            const overlayElement = document.getElementById('selection-overlay');
            const instructionElement = document.getElementById('selection-instruction');
            const isolationElement = document.getElementById('isolation-overlay');
            if (overlayElement) overlayElement.remove();
            if (instructionElement) instructionElement.remove();
            if (isolationElement) isolationElement.remove();

            // Пытаемся удалить обработчики (аналогично PDF)
            // document.removeEventListener('mousedown', startSelection);
            // document.removeEventListener('mousemove', updateSelection);
            // document.removeEventListener('mouseup', endSelection);

        } catch (restoreError) {
            console.warn("Ошибка при восстановлении интерфейса после ошибки PNG:", restoreError);
        }

        if (error.message !== 'Область слишком мала.') {
            alert(`Ошибка экспорта в PNG: ${error.message}\nПроверьте консоль браузера для деталей.`);
        }
    }
};

// --- Вспомогательная функция trimCanvas (убедитесь, что она определена выше или ниже) ---
// Функция для обрезки белых полей с канваса
function trimCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    let minX = width;
    let minY = height;
    let maxX = -1;
    let maxY = -1;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 0) { // Если пиксель не полностью прозрачный
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
    }

    // Если ничего не найдено, вернуть оригинальный канвас
    if (minX > maxX || minY > maxY) {
         console.warn("trimCanvas: Не удалось найти непрозрачные пиксели. Возвращаю оригинальный канвас.");
         return canvas;
    }

    const trimmedWidth = maxX - minX + 1;
    const trimmedHeight = maxY - minY + 1;

    const trimmedCanvas = document.createElement('canvas');
    trimmedCanvas.width = trimmedWidth;
    trimmedCanvas.height = trimmedHeight;
    const trimmedCtx = trimmedCanvas.getContext('2d');
    trimmedCtx.drawImage(canvas, minX, minY, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);

    return trimmedCanvas;
}


</script>
</body>
</html>