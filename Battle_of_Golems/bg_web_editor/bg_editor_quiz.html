<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8" />
	<title>Редактор Уровней</title>
<style>
:root {
  /* Цвета */
  --bg-main: #f8f9fa;
  --text-color: #212529;
  --border-color: #ced4da;
  --btn-bg: #fff;
  --accent: #4a90e2;
  --danger: #ff4d4f;
  --secondary: #6c757d;

  /* Цвета слоёв */
  --layer-0: LimeGreen;  
  --layer-1: MediumOrchid;
  --layer-2: CornflowerBlue;
  --layer-3: Chocolate;

  /* Токены */
  --token-border: #999;

  /* Размеры */
  --radius: 8px;
  --gap: 1rem;
}

body {
  font-family: 'Segoe UI', sans-serif;
  background-color: var(--bg-main);
  margin: 0;
  padding: 20px;
  color: var(--text-color);
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
  justify-content: center;
}

/* === Карточки === */
.card {
  background: white;
  border-radius: var(--radius);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  padding: var(--gap);
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

.card h3,
.card h4 {
  margin-top: 0;
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}

.controls-section {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.layers-control,
.field-settings {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  align-items: center;
  text-align: center;
}

.layer-buttons {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
  border-width: 2px; /* Фиксируем ширину границы */
}

.layer-button.active {
  font-weight: bold;
  /* Не нужно менять border-width */
}

/* === Кнопки слоев === */
.layer-button {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  border-radius: var(--radius);
  cursor: pointer;
  background: var(--btn-bg);
  transition: all 0.2s ease;
  flex: 1 1 auto;
  min-width: 80px;
  text-align: center;
}

.layer-button.active {
  font-weight: bold;
  outline: 2px solid black;
}

.layer-button[data-layer="0"].active { background-color: var(--layer-0); color: white; }
.layer-button[data-layer="1"].active { background-color: var(--layer-1); color: white; }
.layer-button[data-layer="2"].active { background-color: var(--layer-2); color: white; }
.layer-button[data-layer="3"].active { background-color: var(--layer-3); color: white; }

/* Обертка для токена с фоном */
.token-wrapper {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.layer-button:hover:not(.active) {
  background-color: #f0f0f0;
}

/* === Формы === */
input[type="text"],
textarea {
  width: 100%;
  padding: 0.75rem;
  font-size: 1rem;
  border: 1px solid var(--border-color);
  border-radius: var(--radius);
  resize: vertical;
  transition: border 0.2s ease;
  box-sizing: border-box;
}

input:focus,
textarea:focus {
  border-color: var(--accent);
  outline: none;
}

/* === Кнопки действий === */
.action-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
  justify-content: center;
  margin-top: calc(var(--gap) * 2);
}

.action-buttons button i.material-icons {
  font-size: 18px;
  vertical-align: middle;
  margin-right: 6px;
}

.btn {
  padding: 0.75rem 1.25rem;
  border-radius: var(--radius);
  border: none;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.btn.primary {
  background-color: var(--accent);
  color: white;
}

.btn.danger {
  background-color: var(--danger);
  color: white;
}

.btn.secondary {
  background-color: var(--secondary);
  color: white;
}

.btn.tertiary {
  background-color: #e9ecef;
  color: var(--text-color);
}

.btn:hover {
  opacity: 0.9;
}

/* === Токены === */
.tokens-panel {
  min-height: 150px;
}

.token-item {
  display: inline-block;
  margin: 5px;
  cursor: grab;
  user-select: none;
  text-align: center;
  pointer-events: auto;
}

.token-item img {
  width: 60px;
  height: 60px;
  object-fit: contain;
  border: 2px solid var(--token-border);
  border-radius: 3px;
  padding: 2px;
}

.counter {
  font-size: 12px;
  color: gray;
  margin-top: -5px;
  text-align: center;
}

/* === Сетка === */
.main-grid-container {
  position: relative;
  width: 900px;
  aspect-ratio: 1 / 1;
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  grid-template-rows: repeat(10, 1fr);
  gap: 1px;
  background-color: transparent;
}

.grid-cell {
  width: 100%;
  height: 100%;
  background-color: transparent;
  box-sizing: border-box;
  position: relative;
  border: 1px solid var(--border-color);
}

.grid-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: contents;
}

.grid-field {
  position: absolute;
  cursor: move;
  user-select: none;
  width: 100%;
  height: 100%;
  pointer-events: auto;
  object-fit: contain;
  border: 2px solid black;
}

.token {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  max-width: 80%;
  max-height: 80%;
  pointer-events: auto;
  cursor: default !important;
  user-select: none;
}

.token-title {
  font-size: 12px;
  color: var(--text-color);
  text-align: center;
  margin-top: -3px;
}

/**.token.layer-1 { outline: 2px solid var(--layer-1); }
.token.layer-2 { outline: 2px solid var(--layer-2); }
.token.layer-3 { outline: 2px solid var(--layer-3); } **/

/* === Цветные фоны для выделения по слоям === */
/* Цветные фоны для токенов по слоям */
.token-bg-layer-0 { background-color: color-mix(in srgb, var(--layer-0), transparent 30%); }
.token-bg-layer-1 { background-color: color-mix(in srgb, var(--layer-1), transparent 30%); }
.token-bg-layer-2 { background-color: color-mix(in srgb, var(--layer-2), transparent 30%); }
.token-bg-layer-3 { background-color: color-mix(in srgb, var(--layer-3), transparent 30%); }

.selected {
  outline: 4px solid #ff0000 !important;
}

.level-info {
  margin-top: var(--gap);
}

.level-info-inner {
  max-width: 900px; /* совпадает с .main-grid-container */
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
  box-sizing: border-box;
}

.level-info-inner input[type="text"],
.level-info-inner textarea {
  width: 100%;
  font-size: 1rem;
  padding: 0.75rem;
  box-sizing: border-box;
}

/* === Зона корзины === */
.trash-zone {
  width: 15%;
  min-width: 180px;
  height: 900px; /* совпадает с .main-grid-container */
  background-color: #fff;
  border: 2px dashed var(--danger);
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  transition: background-color 0.3s ease;
}

.trash-icon {
  text-align: center;
  color: var(--danger);
}

.trash-icon i.material-icons {
  font-size: 48px;
  display: block;
}

.trash-icon span {
  font-size: 14px;
  margin-top: 10px;
  display: block;
  padding: 0 10px;
}

/* === Печать === */
@media print, screen and (-webkit-min-device-pixel-ratio: 0), not all and (min-resolution: .001dpcm) {
  .grid-cell::before {
    background-color: transparent !important;
  }
}

.print-mode .grid-cell {
  border: none !important;
}

.print-mode .token {
  outline: none !important;
}

.grid-cell::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ddd;
  z-index: -1;
}

.layers-and-fields {
  display: flex;
  justify-content: space-between;
  gap: var(--gap);
}

.layers-control,
.field-settings {
  flex: 1;
  min-width: 250px;
}

.fields-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  align-items: center;
  justify-content: center;
}

/* === Визуальное выделение парных жетонов на панели === */
.token-pair-wrapper {
  display: inline-block;
  margin: 2px;
}

.pair-overlay {
  display: flex;
  align-items: center;
  gap: 2px;
  background-color: #e9ecef; /* Серый фон */
  border-radius: var(--radius);
  padding: 4px 8px;
  margin: 2px;
}

/* === Мобильные устройства === */
@media (max-width: 768px) {
  html {
    font-size: 80%; /* Уменьшаем общий размер шрифта */
  }

  .main-grid-container {
    width: 95vw;
  }

  .container {
    flex-direction: column;
    align-items: stretch;
  }

  .controls-section {
    flex-direction: column;
  }

  .layer-buttons {
    flex-wrap: wrap;
  }

  input[type="text"],
  textarea {
    font-size: 0.85rem;
    padding: 0.5rem;
  }

  .card h3,
  .card h4 {
    font-size: 0.9rem;
  }

  .btn {
    font-size: 0.85rem;
    padding: 0.5rem 1rem;
  }

  .layers-and-fields {
    flex-direction: column;
  }

  .layers-control,
  .field-settings {
    width: 100%;
  }

  /* Уменьшаем кнопки СЛОЙ */
  .layer-button {
    font-size: 0.8rem;
    padding: 0.4rem 0.8rem;
  }

  /* Уменьшаем размеры токенов в 2 раза */
  .token-item img {
    width: 30px;
    height: 30px;
    padding: 1px;
    border-width: 0.5px;
  }

  .counter {
    font-size: 8px;
    margin-top: -3px;
  }

  .token-title {
    font-size: 8px;
    margin-top: -2px;
  }

  .action-buttons {
    margin-top: var(--gap);
    gap: 0.5rem;
  }

  .action-buttons button i.material-icons {
    font-size: 14px;
    margin-right: 4px;
  }

  /* Уменьшаем шрифт у чекбоксов */
  .fields-row label {
    font-size: 0.8rem;
    gap: 0.2rem;
    position: relative;
    padding-left: 0.5em; /* компенсация после скрытия текста */
  }

  .fields-row input[type="checkbox"] {
    transform: scale(0.8);
    margin-right: 0.2rem;
    position: absolute;
    opacity: 0;
    width: 16px;
    height: 16px;
    left: 0;
    top: 0;
    cursor: pointer;
  }
    .trash-zone {
    display: none;
  }
}
  @font-face {
    font-family: 'Material Icons';
    font-style: normal;
    font-weight: 400;
    src: url( https://22176.hostkey.in:34172/pictures/bg_editor/MaterialIcons-Regular.woff2 ) format('woff2');
    font-display: swap;
  }

    .material-icons {
    font-family: 'Material Icons';
    font-weight: normal;
    font-style: normal;
    font-size: 24px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
  }

  /* === Скрытие корзины при недостатке места === */
@media (max-width: 1200px) {
  .trash-zone {
    display: none;
  }
}

.puzzle-icon {
  width: 40px;
  height: 40px;
  object-fit: contain;
  border: 2px solid #ccc;
  border-radius: 5px;
  padding: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  background-color: #fff;
}

.puzzle-icon:hover {
  border-color: var(--accent);
  transform: scale(1.05);
}

.puzzle-icon.active {
  border-color: var(--accent);
  background-color: #e6f7ff;
  transform: scale(1.1);
}

</style>

<!-- Подключение Material Icons -->

</head>
<body>
<div class="container">

  <!-- Панель токенов -->
  <div class="card tokens-panel" id="tokensPanel">
    <div style="display: flex; align-items: center; justify-content: space-between;">
      <h3>Жетоны и фигурки</h3>

      <!-- Переключатель режима -->
        <select id="editorModeSwitcher">
          <option value="level">Уровни</option>
          <option value="puzzle">Головоломки</option>
        </select>

    <!-- Чекбокс использования бонусных токенов -->
    <label>
      <input type="checkbox" id="useBonusTokensCheckbox"> Использовать жетоны Дополнения 1
    </label>
  </div>
 </div>


<!-- Управление сверху -->
<div class="controls-section card">
  <div class="layers-and-fields">
    <!-- Левая часть - Слои -->
    <div class="layers-control">
      <h4>Слои</h4>
      <div class="layer-buttons">
        <button class="layer-button" data-layer="0">Слой 0</button>
        <button class="layer-button active" data-layer="1">Слой 1</button>
        <button class="layer-button" data-layer="2">Слой 2</button>
        <button class="layer-button" data-layer="3">Слой 3</button>
      </div>
    </div>

	<!-- Правая часть - Поля -->
	<div class="field-settings">
	  <h4>Поля</h4>
	  <div class="fields-row">
		<input type="checkbox" checked data-field="4x4"> 4x4</label>
		<input type="checkbox" data-field="2x4_1" class="old-field"> 2x4-1 ↑</label>
		<input type="checkbox" data-field="2x4_2" class="old-field"> 2x4-2 ↑</label>
		<input type="checkbox" data-field="4x2_1" class="new-field"> 4x2-1 →</label>
		<input type="checkbox" data-field="4x2_2" class="new-field"> 4x2-2 →</label>
	  </div>
	</div>
  </div>
</div>

  <!-- Панель условий головоломок -->
  <div class="card" id="puzzlePanelIcons" style="display:none; text-align:center;">
    <div id="puzzleIconsContainer"
        style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;"></div>
  </div>

  <!-- Поле 10x10 -->
  <div class="main-grid-container" id="gridContainer">
    <div class="grid-layer" id="layer0"></div>
    <div class="grid-layer" id="layer1"></div>
    <div class="grid-layer" id="layer2"></div>
    <div class="grid-layer" id="layer3"></div>
  </div>

  <!-- Корзина для удаления токенов -->
  <div class="trash-zone" id="trashZone">
    <div class="trash-icon">
      <i class="material-icons">delete</i>
      <span>Перетащите сюда для удаления</span>
    </div>
  </div>

  <!-- Название и описание уровня -->
  <div class="level-info card">
    <div class="level-info-inner">
      <div>
        <label for="levelNameInput"><strong>Название уровня:</strong></label>
        <input type="text" id="levelNameInput" placeholder="Введите название уровня" />
      </div>
      <div style="margin-top: 1rem;">
        <label for="levelDescription"><strong>Описание уровня:</strong></label>
        <textarea id="levelDescription" rows="4" maxlength="1500"
                  placeholder="Введите описание уровня (максимум 1500 символов)"></textarea>
      </div>
    </div>
  </div>

	<!-- Кнопки -->
	<div class="action-buttons">
	  <button class="btn secondary" id="saveButton"><i class="material-icons">image</i> Сохранить как изображение</button>
	  <button class="btn primary" id="saveLevelButton"><i class="material-icons">save</i> Сохранить уровень</button>
	  <button class="btn tertiary" id="loadLevelButton"><i class="material-icons">folder_open</i> Загрузить уровень</button>
	  <button class="btn danger" id="clearButton"><i class="material-icons">delete_forever</i> Очистить всё</button>
	</div>

</div>

<div id="output" style="margin-top: 40px; text-align: center;"></div>

<!-- Canvas библиотека -->
<script src="https://22176.hostkey.in:34172/pictures/bg_editor/html2canvas.min.js"></script>
<script>

	  // Путь до изображений и помещаем их в локальный кэш
	const IMAGE_PREFIX = 'https://22176.hostkey.in:34172/pictures/bg_editor/';

	const tokens = [
	  { name: 'ВП', image: IMAGE_PREFIX + 'water.png', title: 'Вода ↑', pairGroup: 'water-portal' },
	  { name: 'ПВ', image: IMAGE_PREFIX + 'portal.png', title: '↓ Портал', pairGroup: 'water-portal' },
	  { name: 'ВК', image: IMAGE_PREFIX + 'water.png', title: 'Вода ↑', pairGroup: 'water-stone' },
	  { name: 'КВ', image: IMAGE_PREFIX + 'stone.png', title: '↓ Камень', pairGroup: 'water-stone' },
	  { name: 'Л', image: IMAGE_PREFIX + 'ice.png', title: 'Лёд' },
	  { name: 'Б', image: IMAGE_PREFIX + 'barell.png', title: 'Бочка' },
	  { name: 'Ц', image: IMAGE_PREFIX + 'goal.png', title: 'Целевая точка' },
    { name: 'МБ', image: IMAGE_PREFIX + 'bot_mark.png', title: 'Метка бота' },
	  { name: 'К↑', image: IMAGE_PREFIX + 'red_up.png', value: 'К1', title: 'Красный Голем' },
	  { name: 'C↑', image: IMAGE_PREFIX + 'blue_up.png', value: 'C1', title: 'Синий Голем' },
	  { name: 'З↑', image: IMAGE_PREFIX + 'green_up.png', value: 'З1', title: 'Зелёный Голем' },
	  { name: 'Ж↑', image: IMAGE_PREFIX + 'yellow_up.png', value: 'Ж1', title: 'Жёлтый Голем' },
	  { name: 'ПЛ', image: IMAGE_PREFIX + 'line_straight.png', title: 'Прямая линия ↑', pairGroup: 'line-pair' },
	  { name: 'УЛ', image: IMAGE_PREFIX + 'line_corner.png', title: '↓ Угловая линия', pairGroup: 'line-pair' },
    { name: 'ВУТ', image: IMAGE_PREFIX + 'duck.png', title: 'Вода с Уточкой ↑', pairGroup: 'bonus-pair' },
    { name: 'ПРЖ', image: IMAGE_PREFIX + 'spring.png', title: '↓ Прыжок', pairGroup: 'bonus-pair' },
    { name: 'AM1', image: IMAGE_PREFIX + 'aruco1.png', title: 'ArUco 1 ↑', pairGroup: 'aruco-pair1' },
    { name: 'AM2', image: IMAGE_PREFIX + 'aruco2.png', title: 'ArUco 2 ↓', pairGroup: 'aruco-pair1' },
    { name: 'AM3', image: IMAGE_PREFIX + 'aruco3.png', title: 'ArUco 3 ↑', pairGroup: 'aruco-pair2' },
    { name: 'AM1_2', image: IMAGE_PREFIX + 'aruco1.png', title: '↓ ArUco 1', pairGroup: 'aruco-pair2' },
    { name: 'AM2_2', image: IMAGE_PREFIX + 'aruco2.png', title: 'ArUco 2 ↑', pairGroup: 'aruco-pair3' },
    { name: 'AM3_2', image: IMAGE_PREFIX + 'aruco3.png', title: '↓ ArUco 3', pairGroup: 'aruco-pair3' }
	];
  
  const tokenLimits = {
  'ВП': 2, 'ПВ': 2,
  'ВК': 4, 'КВ': 4,
  'Л': 6,
  'Б': 5,
  'К1': 1,
  'C1': 1,
  'З1': 1,
  'Ж1': 1,
  'ПЛ': 4,
  'УЛ': 4,
  'ВУТ': 1,
  'ПРЖ': 1,
  'AM1': 2, 
  'AM2': 2, 
  'AM3': 2,
  'AM1_2': 2,
  'AM2_2': 2,
  'AM3_2': 2
  };
  
  const layers = [0, 1, 2, 3];
//  let currentLayer = 1;

// Инициализация позиций полей
	const fieldPositions = {
	  "4x4": { row: 0, col: 3 },
	  "2x4_1": { row: 0, col: 0 },
	  "2x4_2": { row: 0, col: 8 },
	  "4x2_1": { row: 0, col: 0 }, // Пример начальной позиции
	  "4x2_2": { row: 0, col: 6 }  // Пример начальной позиции
	};
	
	const userFieldPositions = {};

// Разрешенные жетоны для слоев
const allowedValues = {
  0: [], // Только фоновые поля
  1: ['ВП', 'ВК', 'КВ', 'ПВ', 'Л', 'Ц', 'Б', 'К1', 'C1', 'З1', 'Ж1', 'ПЛ', 'УЛ', 'ВУТ', 'ПРЖ', 'AM1', 'AM2', 'AM3', 'AM1_2', 'AM2_2', 'AM3_2'],
  2: ['Л', 'Б', 'Ц', 'МБ', 'К1', 'C1', 'З1', 'Ж1'],
  3: ['Б', 'Ц', 'МБ', 'К1', 'C1', 'З1', 'Ж1']
};

 let currentLayer = 1;

  // Инициализация сетки: 10 строк × 10 столбцов
  const grid = Array.from({ length: 10 }, () =>
    Array.from({ length: 10 }, () => ['', '', '']) // layers 1, 2, 3
  );
  
  const gridContainer = document.getElementById('gridContainer');
  for (let row = 0; row < 10; row++) {
    for (let col = 0; col < 10; col++) {
      const cell = document.createElement('div');
      cell.classList.add('grid-cell');
      cell.dataset.row = row;
      cell.dataset.col = col;
      cell.addEventListener('dragover', e => e.preventDefault());

  cell.addEventListener('drop', e => {
  e.preventDefault();
  cell.style.backgroundColor = '';
  if (currentLayer === 0) return;

  const tokenName = e.dataTransfer.getData('text/plain');
  const fromRow = parseInt(e.dataTransfer.getData('from-row'));
  const fromCol = parseInt(e.dataTransfer.getData('from-col'));
  const rotation = e.dataTransfer.getData('rotation'); // <-- Получаем поворот

  const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
  if (!token) return;

  const tokenValue = token.value || token.name;
  if (!allowedValues[currentLayer].includes(tokenValue)) {
    alert(`На слое ${currentLayer} нельзя разместить "${token.name}"`);
    return;
  }

  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  const layerIndex = currentLayer - 1;

  // Если это перетаскивание с другой ячейки — удаляем из старой
  if (!isNaN(fromRow) && !isNaN(fromCol)) {
    grid[fromRow][fromCol][layerIndex] = '';
  }

  grid[row][col][layerIndex] = token.name;

  updateCell(cell, row, col);

  // Применяем поворот к новому элементу
  const rotationKey = `rotation_${row}_${col}_${token.name}_layer${currentLayer}`;
  localStorage.setItem(rotationKey, rotation);

  // Находим wrapper после обновления ячейки
  const wrapper = cell.querySelector('.token-wrapper');
  if (wrapper && rotation) {
    wrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
  }

  validateLimits();
  updateTokenCounters();
  saveStateToLocalStorage();
});

      gridContainer.appendChild(cell);
    }
  }

const puzzleConditions = [
  // 1. Уровень сложности (картинки lvl1...lvl5)
  { key: 'lvl1', image: IMAGE_PREFIX + 'lvl1.png' },
  { key: 'lvl2', image: IMAGE_PREFIX + 'lvl2.png' },
  { key: 'lvl3', image: IMAGE_PREFIX + 'lvl3.png' },
  { key: 'lvl4', image: IMAGE_PREFIX + 'lvl4.png' },
  { key: 'lvl5', image: IMAGE_PREFIX + 'lvl5.png' },

  // 2–4. Бонусы (повтор, условие, атака, защита, бот1, бот2)
  { key: 'repeat2', image: IMAGE_PREFIX + 'repeat2.png' },
  { key: 'condition', image: IMAGE_PREFIX + 'condition.png' },
  { key: 'attack', image: IMAGE_PREFIX + 'attack.png' },
  { key: 'defense', image: IMAGE_PREFIX + 'defense.png' },
  { key: 'bot1', image: IMAGE_PREFIX + 'bot1.png' },
  { key: 'bot2', image: IMAGE_PREFIX + 'bot2.png' },

  // 5. Число строк программы (line1...line6, lineN)
  { key: 'line1', image: IMAGE_PREFIX + 'line1.png' },
  { key: 'line2', image: IMAGE_PREFIX + 'line2.png' },
  { key: 'line3', image: IMAGE_PREFIX + 'line3.png' },
  { key: 'line4', image: IMAGE_PREFIX + 'line4.png' },
  { key: 'line5', image: IMAGE_PREFIX + 'line5.png' },
  { key: 'line6', image: IMAGE_PREFIX + 'line6.png' },
  { key: 'lineN', image: IMAGE_PREFIX + 'lineN.png' }
];

const fieldImages = {
  "4x4": [
    IMAGE_PREFIX + "pole_4x4.png",
    IMAGE_PREFIX + "pole_4x4_alt.png"
  ],
  "2x4_1": [
    IMAGE_PREFIX + "pole_2x4_1.png",
    IMAGE_PREFIX + "pole_2x4_1_alt.png"
  ],
  "2x4_2": [
    IMAGE_PREFIX + "pole_2x4_2.png",
    IMAGE_PREFIX + "pole_2x4_2_alt.png"
  ],
  "4x2_1": [
    IMAGE_PREFIX + "pole_4x2_1.png",
    IMAGE_PREFIX + "pole_4x2_1_alt.png"
  ],
  "4x2_2": [
    IMAGE_PREFIX + "pole_4x2_2.png",
    IMAGE_PREFIX + "pole_4x2_2_alt.png"
  ]
};

// === Функция кэширования изображений ===
function cacheImage(url) {
  const cached = localStorage.getItem(`cached_image_${url}`);
  if (cached) return Promise.resolve(cached);

  return fetch(url)
    .then(response => response.blob())
    .then(blob => {
      const reader = new FileReader();
      return new Promise(resolve => {
        reader.onload = () => {
          localStorage.setItem(`cached_image_${url}`, reader.result);
          resolve(reader.result);
        };
        reader.readAsDataURL(blob);
      });
    })
    .catch(() => url); // fallback на исходный URL
}

// === Сбор всех уникальных URL изображений ===
  function getAllImageUrls() {
    const urls = new Set();
    tokens.forEach(token => {
      urls.add(token.image);
    });
    Object.keys(fieldPositions).forEach(key => {
      urls.add(IMAGE_PREFIX + `pole_${key}.png`);
      urls.add(IMAGE_PREFIX + `pole_${key}_alt.png`); // <-- добавлено
    });
      puzzleConditions.forEach(condition => {
      urls.add(condition.image);
    });
    urls.add(IMAGE_PREFIX + 'empty.png');
    return Array.from(urls);
  }

  async function preloadAllImages() {
    const urls = getAllImageUrls();
    const promises = urls.map(url => cacheImageWithExpiry(url));
    await Promise.all(promises);
    console.log("Все изображения (токены, поля, головоломки) закэшированы");
  }

preloadAllImages(); // Выполняем при загрузке страницы

function getCachedImageURL(url) {
  const cached = localStorage.getItem(`cached_image_${url}`);
  if (!cached) {
    // Если нет в кэше, предзагружаем
    cacheImageWithExpiry(url).catch(() => {});
    return url;
  }
  return cached;
}

// Проверка доступности локального хранилища
function isLocalStorageAvailable() {
  try {
    const test = '__test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch (e) {
    return false;
  }
}

if (!isLocalStorageAvailable()) {
  alert("localStorage недоступен. Сохранение невозможно.");
}

function updateCell(cell, row, col, layer = currentLayer) {
  cell.innerHTML = '';

  for (let i = 0; i < 3; i++) {
    const tokenName = grid[row][col][i];
    if (tokenName) {
      const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
      if (!token || !token.image) continue;

      const img = document.createElement('img');
      img.src = getCachedImageURL(token.image);
      img.alt = tokenName;
      img.title = tokenName;
      img.className = 'token';
      img.crossOrigin = 'anonymous';
      img.draggable = true;

      const layerIndex = i + 1;
      const rotationKey = `rotation_${row}_${col}_${tokenName}_layer${layerIndex}`;
      let rotation = parseInt(localStorage.getItem(rotationKey)) || 0;

      const wrapper = document.createElement('div');
      wrapper.className = 'token-wrapper';
      wrapper.dataset.token = tokenName;
      wrapper.dataset.layer = layerIndex;
      wrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
      wrapper.appendChild(img);

      // Обработчик контекстного меню (ПКМ)
      wrapper.oncontextmenu = function(e) {
        e.preventDefault();
        
        if (layerIndex !== currentLayer) {
          console.warn(`Нельзя вращать: слой ${layerIndex}, активен слой ${currentLayer}`);
          return;
        }

        rotation = (rotation + 90) % 360;
        this.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
        localStorage.setItem(rotationKey, rotation);
        saveStateToLocalStorage();
      };

      // Обработчик начала перетаскивания
      wrapper.addEventListener('dragstart', function(e) {
        if (layerIndex !== currentLayer) {
          console.warn(`Нельзя перетаскивать: слой ${layerIndex}, активен слой ${currentLayer}`);
          e.preventDefault();
          return;
        }

        e.dataTransfer.setData('text/plain', token.name);
        e.dataTransfer.setData('from-row', row);
        e.dataTransfer.setData('from-col', col);
        e.dataTransfer.setData('rotation', rotation.toString());

        const size = 60;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        const imgForCanvas = new Image();
        imgForCanvas.src = getCachedImageURL(token.image);
        imgForCanvas.onload = () => {
          const angle = rotation * Math.PI / 180;
          ctx.translate(size / 2, size / 2);
          ctx.rotate(angle);
          ctx.drawImage(imgForCanvas, -size / 2, -size / 2, size, size);
          e.dataTransfer.setDragImage(canvas, size / 2, size / 2);
        };
      });

      // Обработчики для тач-устройств
      let lastTapTime = 0;
      let longPressTimer;

      wrapper.ontouchstart = function(e) {
        if (layerIndex !== currentLayer) {
          console.warn(`Нельзя вращать: слой ${layerIndex}, активен слой ${currentLayer}`);
          return;
        }

        longPressTimer = setTimeout(() => {
          grid[row][col][i] = '';
          updateCell(cell, row, col);
          validateLimits();
          updateTokenCounters();
          saveStateToLocalStorage();
        }, 800);

        const now = Date.now();
        const timeDiff = now - lastTapTime;
        if (timeDiff > 0 && timeDiff < 300) {
          rotation = (rotation + 90) % 360;
          this.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
          localStorage.setItem(rotationKey, rotation);
          saveStateToLocalStorage();
        }
        lastTapTime = now;
        e.preventDefault();
      };

      wrapper.ontouchend = function() {
        clearTimeout(longPressTimer);
      };

      // Цветной фон для активного слоя
      if (layerIndex === layer) {
        const bgDiv = document.createElement('div');
        bgDiv.className = `token-bg-layer-${layer}`;
        bgDiv.dataset.bgLayer = "true";
        bgDiv.style.position = 'absolute';
        bgDiv.style.top = 0;
        bgDiv.style.left = 0;
        bgDiv.style.width = '100%';
        bgDiv.style.height = '100%';
        bgDiv.style.zIndex = '-1';
        wrapper.appendChild(bgDiv);
      }

      cell.appendChild(wrapper);
    }
  }
}

// === Транслитерация кириллицы в латиницу ===
function transliterate(text) {
  const map = {
    'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd',
    'е': 'e', 'ё': 'yo', 'ж': 'zh', 'з': 'z', 'и': 'i',
    'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n',
    'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't',
    'у': 'u', 'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch',
    'ш': 'sh', 'щ': 'shch', 'ы': 'y', 'э': 'e', 'ю': 'yu',
    'я': 'ya', 'і': 'i', 'ї': 'yi', 'є': 'ye'
  };
  return text.split('')
    .map(char => map[char.toLowerCase()] || char)
    .join('')
    .replace(/[^a-zA-Z0-9]/g, '_')
    .toLowerCase();
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Delete' || e.key === 'Del') {
    const selected = document.querySelector('.token.selected');
    if (selected) {
      const cell = selected.closest('.grid-cell');
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      const layerIndex = [...document.querySelectorAll('.layer-button')]
                         .findIndex(btn => btn.classList.contains('active')) - 1;
      if (layerIndex >= 0) {
        grid[row][col][layerIndex] = '';
        updateCell(cell, row, col);
		validateLimits();
		updateTokenStyles();
		updateTokenCounters();
		saveStateToLocalStorage();
      }
    }
  }
});


// Сохранение при изменении "Название уровня"
document.getElementById('levelNameInput').addEventListener('input', () => {
  saveStateToLocalStorage();
});

// Сохранение при изменении "Описание уровня"
document.getElementById('levelDescription').addEventListener('input', () => {
  saveStateToLocalStorage();
});

// --- Функция для обновления стилей токенов ---
function updateTokenStyles() {
  const activeTokens = tokens.filter(t => {
    const tokenValue = t.value || t.name;
    return allowedValues[currentLayer].includes(tokenValue);
  });

  const limitsExceeded = areTokensAvailable();

  document.querySelectorAll('.token-item').forEach(div => {
    const img = div.querySelector('img');
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
    const tokenValue = token.value || token.name;

    if (!allowedValues[currentLayer].includes(tokenValue)) {
      div.style.opacity = '0.4';
      div.style.cursor = 'not-allowed';
      div.setAttribute('title', 'Нельзя разместить на этом слое');
      div.draggable = false;
    } else if (limitsExceeded[tokenValue]) {
      div.style.opacity = '0.4';
      div.style.cursor = 'not-allowed';
      div.setAttribute('title', 'Превышен лимит для этого жетона');
      div.draggable = false;
    } else {
      div.style.opacity = '1';
      div.style.cursor = 'grab';
      div.removeAttribute('title');
      div.draggable = true;
    }
  });
}

// --- Инициализация токенов ---

// Группируем токены по pairGroup
const groupedTokens = {};
tokens.forEach(token => {
  const group = token.pairGroup || token.name;
  if (!groupedTokens[group]) groupedTokens[group] = [];
  groupedTokens[group].push(token);
});

// Создаем элементы
Object.values(groupedTokens).forEach(group => {
  const isPair = group.length > 1;

  // Общая обёртка для группы (парных или одиночных)
  const wrapper = document.createElement('div');
  wrapper.classList.add('token-pair-wrapper');

  // Серая подложка
  const grayOverlay = document.createElement('div');
  grayOverlay.classList.add('pair-overlay');

  group.forEach(token => {
    const div = document.createElement('div');
    div.classList.add('token-item');

    // Обёртка для изображения и заголовка
    const wrapper = document.createElement('div');

    // Добавляем название, если оно есть
    if (token.title) {
      const title = document.createElement('div');
      title.className = 'token-title';
      title.textContent = token.title;
      wrapper.appendChild(title);
    }

    const img = document.createElement('img');
    img.src = getCachedImageURL(token.image);
    img.alt = token.name;
    img.title = token.name;

    if (token.pairGroup) {
        wrapper.dataset.pairGroup = token.pairGroup; // метка для контейнера
        img.dataset.pairGroup = token.pairGroup;     // метка для изображения
      
    }

    wrapper.appendChild(img);
    div.appendChild(wrapper);

    // Добавляем возможность перетаскивания
    div.draggable = true;
    div.addEventListener('dragstart', e => {
      const tokenValue = token.value || token.name;
      if (!allowedValues[currentLayer].includes(tokenValue)) {
        e.preventDefault();
      } else {
        e.dataTransfer.setData('text/plain', token.name);
      }
    });

    grayOverlay.appendChild(div);
  });

  wrapper.appendChild(grayOverlay);
  tokensPanel.appendChild(wrapper);
});

updateTokenStyles();

document.querySelectorAll('.token-item').forEach(div => {
  div.addEventListener('dragstart', e => {
    const img = div.querySelector('img');
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
    const tokenValue = token?.value || token?.name;

    // Проверяем, можно ли размещать этот токен на текущем слое
    if (!allowedValues[currentLayer].includes(tokenValue)) {
      e.preventDefault(); // Запрещаем перетаскивание, если токен не подходит
    } else {
      e.dataTransfer.setData('text/plain', token.name); // Передаем имя токена
    }
  });
});

document.querySelectorAll('.token-item').forEach(div => {
  let tokenName = div.querySelector('img')?.alt;
  let longPressTimer;

	// === Поддержка перетаскивания жетонов на мобильных устройствах ===
	let isDragging = false;
	let dragPreview = null;

	div.addEventListener('touchstart', function(e) {
	
	  e.preventDefault(); // <-- Основное решение
	
	  const tokenName = this.querySelector('img')?.alt;
	  const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
	  const tokenValue = token?.value || token?.name;

	  if (!allowedValues[currentLayer].includes(tokenValue)) {
		e.preventDefault();
		return;
	  }

	  // Создаем прозрачный элемент-представление
	  dragPreview = document.createElement('img');
	  dragPreview.src = getCachedImageURL(token.image);
	  dragPreview.style.position = 'fixed';
	  dragPreview.style.top = '0px';
	  dragPreview.style.left = '0px';
	  dragPreview.style.width = '60px';
	  dragPreview.style.height = '60px';
	  dragPreview.style.opacity = '0.5';
	  dragPreview.style.pointerEvents = 'none';
	  dragPreview.style.zIndex = '9999';
	  dragPreview.style.transform = 'translate(-50%, -50%)';
	  document.body.appendChild(dragPreview);

	  isDragging = true;

	  const touch = e.touches[0];
	  updateDragPreviewPosition(touch.clientX, touch.clientY);

	  // Эмулируем начало drag
	  const event = new MouseEvent('mousedown', {
		clientX: touch.clientX,
		clientY: touch.clientY,
		bubbles: true
	  });
	  div.dispatchEvent(event);
	});

	div.addEventListener('touchmove', function(e) {
	  if (!isDragging) return;
	  
	  e.preventDefault(); // <-- Отменяем прокрутку при движении
	  
	  const touch = e.touches[0];
	  updateDragPreviewPosition(touch.clientX, touch.clientY);

	  const event = new MouseEvent('mousemove', {
		clientX: touch.clientX,
		clientY: touch.clientY,
		bubbles: true
	  });
	  div.dispatchEvent(event);
	});

	div.addEventListener('touchend', function(e) {
	  if (dragPreview) {
		dragPreview.remove();
		dragPreview = null;
	  }
	  isDragging = false;

	  const event = new MouseEvent('mouseup', {
		bubbles: true
	  });
	  div.dispatchEvent(event);

	  // Эмулируем drop на ячейке под пальцем
	  const touch = e.changedTouches[0];
	  const target = document.elementFromPoint(touch.clientX, touch.clientY);
	  const cell = target.closest('.grid-cell');
	  if (cell) {
		const dropEvent = new DragEvent('drop', {
		  dataTransfer: new DataTransfer(),
		  bubbles: true,
		  cancelable: true
		});

		const tokenName = this.querySelector('img')?.alt;
		dropEvent.dataTransfer.setData('text/plain', tokenName); // tokenName доступен здесь
		cell.dispatchEvent(dropEvent);
	  }
	});

	function updateDragPreviewPosition(x, y) {
	  if (dragPreview) {
		dragPreview.style.top = `${y}px`;
		dragPreview.style.left = `${x}px`;
	  }
	}

});

// --- Событие dragover и drop на ячейках сетки ---
document.querySelectorAll('.grid-cell').forEach(cell => {
  cell.addEventListener('dragover', e => {
    e.preventDefault();
    cell.style.backgroundColor = '#aaffaa'; // Подсветка
  });

  cell.addEventListener('dragleave', () => {
    cell.style.backgroundColor = ''; // Сброс подсветки
  });

  cell.addEventListener('drop', e => {
    e.preventDefault();
    cell.style.backgroundColor = '';

    if (currentLayer === 0) return;

    const tokenName = e.dataTransfer.getData('text/plain');
    const fromRow = parseInt(e.dataTransfer.getData('from-row'), 10);
    const fromCol = parseInt(e.dataTransfer.getData('from-col'), 10);
    const rotation = e.dataTransfer.getData('rotation');

    const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
    if (!token) return;

    const tokenValue = token.value || token.name;
    if (!allowedValues[currentLayer].includes(tokenValue)) {
      alert(`На слое ${currentLayer} нельзя разместить "${token.name}"`);
      return;
    }

    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const layerIndex = currentLayer - 1;

    // Проверка: нельзя снять с НЕактивного слоя
    if (!isNaN(fromRow) && !isNaN(fromCol)) {
      // Определяем слой жетона на старой ячейке:
      const fromLayerIndex = layerIndex; // ты можешь передавать его тоже в dragstart при желании
      const fromTokenLayer = fromLayerIndex + 1;

      if (fromTokenLayer !== currentLayer) {
        alert("Нельзя перемещать жетон с другого слоя!");
        return;
      }
    }

    // Удалить старый
    if (!isNaN(fromRow) && !isNaN(fromCol)) {
      grid[fromRow][fromCol][layerIndex] = '';
      const oldKey = `rotation_${fromRow}_${fromCol}_${tokenName}_layer${currentLayer}`;
      localStorage.removeItem(oldKey);

      const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
      if (fromCell) updateCell(fromCell, fromRow, fromCol);
    }

    grid[row][col][layerIndex] = token.name;

    const newKey = `rotation_${row}_${col}_${token.name}_layer${currentLayer}`;
    localStorage.setItem(newKey, rotation);

    if (!validateLimits()) {
      grid[row][col][layerIndex] = '';
      localStorage.removeItem(newKey);
      alert("Превышен лимит!");
    }

    updateCell(cell, row, col);
    updateTokenCounters();
    updateTokenStyles();
    saveStateToLocalStorage();
  });

});


  // --- Обновление стилей при смене слоя ---
  document.querySelectorAll('.layer-button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.layer-button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentLayer = parseInt(btn.dataset.layer);

      // Убираем выделение у всех токенов
      document.querySelectorAll('.token.selected').forEach(token => {
        token.classList.remove('selected');
      });

      // Обновляем отображение ячеек
      document.querySelectorAll('.grid-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        updateCell(cell, row, col, currentLayer);
      });

      const fieldImageIndices = {};
      document.querySelectorAll('.grid-field').forEach(img => {
        fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
      });
      drawGameFields(fieldImageIndices);

      updateTokenStyles(); // обновляем стили токенов
      updateTokenCounters(); // <-- добавлено
      saveStateToLocalStorage();
    });
  });

    document.querySelectorAll('[data-field]').forEach(cb => {
      cb.addEventListener('change', () => {
        const fieldImageIndices = {};
        document.querySelectorAll('.grid-field').forEach(img => {
          fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
        });
        drawGameFields(fieldImageIndices);
      });
    });


  function drawGameFields(imageIndices = {}) {
    const layer0 = document.getElementById('layer0');
    layer0.innerHTML = ''; // Очищаем текущие элементы

    const activeElements = [];
    document.querySelectorAll('[data-field]').forEach(cb => {
      const key = cb.dataset.field;
      if (cb.checked) {
        const pos = userFieldPositions[key] || fieldPositions[key] || { row: 0, col: 0 };
        let rowsSpan, colsSpan;
        if (key === '4x4') {
          rowsSpan = colsSpan = 4;
        } else if (key.startsWith('2x4')) {
          rowsSpan = 4;
          colsSpan = 2;
        } else if (key.startsWith('4x2')) {
          rowsSpan = 2;
          colsSpan = 4;
        }

        const images = fieldImages[key];
        let index = 0;
        if (imageIndices && key in imageIndices) {
          index = imageIndices[key];
        } else {
          const storedIndex = localStorage.getItem(`fieldImageIndex_${key}`);
          index = storedIndex !== null ? parseInt(storedIndex) : 0;
        }

        const imgUrl = images[index];
        const cachedUrl = getCachedImageURL(imgUrl);
        const img = createField(cachedUrl, key, pos.row, pos.col, rowsSpan, colsSpan);
        img.dataset.imageIndex = index; // <-- запоминаем текущий индекс
        layer0.appendChild(img);
        activeElements.push(img);
        }
    });

    if (currentLayer === 0) makeDraggable(activeElements);
  }

// Работаем с полем на 0 слое - смена типа
function createField(src, key, row, col, rowsSpan, colsSpan) {
  const img = document.createElement('img');
  img.src = src;
  img.dataset.fieldKey = key;
  img.classList.add('grid-field');
  img.style.gridRowStart = row + 1;
  img.style.gridColumnStart = col + 1;
  img.style.gridRowEnd = `span ${rowsSpan}`;
  img.style.gridColumnEnd = `span ${colsSpan}`;

  // Сохраняем начальный индекс изображения из localStorage
  let imageIndex = parseInt(localStorage.getItem(`fieldImageIndex_${key}`)) || 0;
  img.dataset.imageIndex = imageIndex;

  // === Событие ПКМ (для десктопа) ===
  img.addEventListener("contextmenu", function (e) {
    e.preventDefault();

    const images = fieldImages[key];
    if (!images || images.length < 2) return;

    let currentIndex = parseInt(this.dataset.imageIndex || '0');
    let nextIndex = (currentIndex + 1) % images.length;

    const newSrc = getCachedImageURL(images[nextIndex]);
    this.src = newSrc;
    this.dataset.imageIndex = nextIndex;

    localStorage.setItem(`fieldImageIndex_${key}`, nextIndex);

    const currentCol = parseInt(this.style.gridColumnStart) - 1;
    const currentRow = parseInt(this.style.gridRowStart) - 1;
    userFieldPositions[key] = { row: currentRow, col: currentCol };
    saveStateToLocalStorage();
  });

  // === Двойной тап для смены изображения ===
  let lastTapTime = 0;

  img.addEventListener('touchstart', function (e) {
    const now = Date.now();
    const timeDiff = now - lastTapTime;

    if (timeDiff < 300 && timeDiff > 0) {
      // Двойной тап — меняем изображение
      const images = fieldImages[key];
      if (!images || images.length < 2) return;

      let currentIndex = parseInt(this.dataset.imageIndex || '0');
      let nextIndex = (currentIndex + 1) % images.length;

      const newSrc = getCachedImageURL(images[nextIndex]);
      this.src = newSrc;
      this.dataset.imageIndex = nextIndex;

      localStorage.setItem(`fieldImageIndex_${key}`, nextIndex);

      const currentCol = parseInt(this.style.gridColumnStart) - 1;
      const currentRow = parseInt(this.style.gridRowStart) - 1;
      userFieldPositions[key] = { row: currentRow, col: currentCol };
      saveStateToLocalStorage();
    }

    lastTapTime = now;
  });

  return img;
}


function makeDraggable(elements) {
  for (const el of elements) {
    el.style.zIndex = 1000;
    el.draggable = false;

    let shiftX = 0, shiftY = 0;
    let isDragging = false;
    let touchId = null; // Для отслеживания конкретного касания

    function getEventClientX(e) {
      return e.touches ? e.touches[0].clientX : e.clientX;
    }

    function getEventClientY(e) {
      return e.touches ? e.touches[0].clientY : e.clientY;
    }

    function handleMouseDown(e) {
      if (currentLayer !== 0) return;
      e.preventDefault();

      const rect = gridContainer.getBoundingClientRect();
      const computedStyle = getComputedStyle(gridContainer);
      const paddingLeft = parseFloat(computedStyle.paddingLeft);
      const paddingTop = parseFloat(computedStyle.paddingTop);
      const actualWidth = rect.width - paddingLeft * 2;
      const actualHeight = rect.height - paddingTop * 2;
      const cellWidth = actualWidth / 10;
      const cellHeight = actualHeight / 10;

      shiftX = getEventClientX(e) - el.getBoundingClientRect().left;
      shiftY = getEventClientY(e) - el.getBoundingClientRect().top;

      const colsSpan = parseInt(el.style.gridColumnEnd.replace('span ', ''), 10);
      const rowsSpan = parseInt(el.style.gridRowEnd.replace('span ', ''), 10);

      function moveAt(pageX, pageY) {
        const x = pageX - rect.left - shiftX;
        const y = pageY - rect.top - shiftY;

        const col = Math.floor(x / cellWidth);
        const row = Math.floor(y / cellHeight);

        const safeCol = Math.max(0, Math.min(10 - colsSpan, col));
        const safeRow = Math.max(0, Math.min(10 - rowsSpan, row));

        el.style.gridColumnStart = safeCol + 1;
        el.style.gridRowStart = safeRow + 1;

//        const fieldKey = el.src.split('/').pop().replace('.png', '').replace('pole_', '');
        const fieldKey = el.dataset.fieldKey;
        userFieldPositions[fieldKey] = { row: safeRow, col: safeCol };
        saveStateToLocalStorage();
      }

      function onMouseMove(ev) {
        moveAt(getEventClientX(ev), getEventClientY(ev));
      }

      function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        document.removeEventListener('touchmove', onMouseMove);
        document.removeEventListener('touchend', onMouseUp);
        isDragging = false;
        touchId = null;
      }

      if (e.type === 'touchstart') {
        touchId = e.touches[0].identifier;
      }

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('touchmove', onMouseMove, { passive: false });
      document.addEventListener('touchend', onMouseUp);

      isDragging = true;
    }

    el.addEventListener('mousedown', handleMouseDown);
    el.addEventListener('touchstart', handleMouseDown, { passive: false });

    el.ondragstart = () => false;
  }
}

function countTokens() {
  const counts = {};
  for (let row of grid) {
    for (let cell of row) {
      for (let tile of cell) {
        if (!tile) continue;
        const token = tokens.find(t => t.name === tile || t.value === tile);
        const key = token?.value || token?.name;
        if (key && !counts[key]) counts[key] = 0;
        if (key) counts[key]++;
      }
    }
  }
  return counts;
}

// Просчет и проверка лимитов жетонов
function validateLimits(triggeringRow = null, triggeringCol = null, triggeringLayer = null) {
	const counts = countTokens();

	const red = (counts['К1'] || 0);
	const blue = (counts['C1'] || 0);
	const green = (counts['З1'] || 0);
	const yellow = (counts['Ж1'] || 0);

	const portalCount = (counts['ВП'] || 0) + (counts['ПВ'] || 0);
	const stoneCount = (counts['ВК'] || 0) + (counts['КВ'] || 0);
	const waterSurfaceCount = (counts['ВК'] || 0); // только ВК считается за водную поверхность
	const stoneSurfaceCount = (counts['КВ'] || 0); // только КВ считается за каменную поверхность
	const lineCount = (counts['ПЛ'] || 0) + (counts['УЛ'] || 0);
  const bonusCount = (counts['ВУТ'] || 0) + (counts['ПРЖ'] || 0);
  const arucoCount1 = (counts['AM1'] || 0) + (counts['AM2'] || 0);
  const arucoCount2 = (counts['AM3'] || 0) + (counts['AM1_2'] || 0);
  const arucoCount3 = (counts['AM2_2'] || 0) + (counts['AM3_2'] || 0);


	const exceeded = [];

	if (portalCount > 2)
	  exceeded.push("Максимум 2 портала!");

	if (stoneCount > 4)
	  exceeded.push("Максимум 4 камня/водной поверхности вместе!");

	if (waterSurfaceCount > 6)
	  exceeded.push("Превышено количество водных поверхностей!");

	if ((counts['Б'] || 0) > 5)
	  exceeded.push("Максимум 5 бочек!");

	if ((counts['Л'] || 0) > 6)
	  exceeded.push("Максимум 6 жетонов Льда!");
  if (red > 1) exceeded.push("Только один красный голем!");
  if (blue > 1) exceeded.push("Только один синий голем!");
  if (green > 1) exceeded.push("Только один зелёный голем!");
  if (yellow > 1) exceeded.push("Только один жёлтый голем!");
  
  if (lineCount > 4) exceeded.push("Максимум 4 жетона линий (ПЛ/УЛ)!");
  if (bonusCount > 1) exceeded.push("Максимум 1 жетона уточка-пружина (ВУТ/ПРЖ)!");
  if (arucoCount1 > 1) exceeded.push("Максимум 1 жетона AruCo данного вида (AM1/AM2)!");
  if (arucoCount2 > 1) exceeded.push("Максимум 1 жетона AruCo данного вида (AM3/AM1)!");
  if (arucoCount3 > 1) exceeded.push("Максимум 1 жетона AruCo данного вида (AM2/AM3)!");


  updateTokenCounters(); // <-- всегда обновляем счетчики после валидации

  if (exceeded.length > 0 && triggeringRow !== null) {
    console.warn("Превышен лимит:", exceeded);
    return false;
  }

  updateTokenStyles();

  return exceeded.length === 0;

//  return true;
}

// Обновление счетчика под жетонами
  function updateTokenCounters() {
    const counts = countTokens();
    document.querySelectorAll('.token-item').forEach(div => {
      const img = div.querySelector('img');
      const tokenName = img.alt;
      const token = tokens.find(t => t.name === tokenName || t.value === tokenName);
      const tokenValue = token?.value || token?.name;
      const limit = tokenLimits[tokenValue] || 0;
      const current = counts[tokenValue] || 0;
      let counter = div.querySelector('.counter');
      if (!counter) {
        counter = document.createElement('div');
        counter.className = 'counter';
        div.appendChild(counter);
      }
      counter.textContent = `${current}/${limit}`;
    });
  }

// Включение  и выключение токенов по лимиту
// Проверяет, превышен ли лимит у токенов (возвращает объект с флагами)
function areTokensAvailable() {
  const counts = countTokens();
  const limitsExceeded = {};

  // Суммы по группам
  const red = ['К1'].reduce((sum, k) => sum + (counts[k] || 0), 0);
  const blue = ['C1'].reduce((sum, k) => sum + (counts[k] || 0), 0);
  const green = ['З1'].reduce((sum, k) => sum + (counts[k] || 0), 0);
  const yellow = ['Ж1'].reduce((sum, k) => sum + (counts[k] || 0), 0);

  const portalCount = (counts['ВП'] || 0) + (counts['ПВ'] || 0); // портальные токены
  const stoneWaterCount = (counts['ВК'] || 0) + (counts['КВ'] || 0); // камень + вода

  // Проверяем отдельные лимиты
  limitsExceeded['ВП'] = limitsExceeded['ПВ'] = portalCount >= 2;
  limitsExceeded['ВК'] = limitsExceeded['КВ'] = stoneWaterCount >= 4; // Теперь ВК тоже имеет лимит 4 вместе с КВ
  limitsExceeded['Л'] = (counts['Л'] || 0) >= 6;
  limitsExceeded['Б'] = (counts['Б'] || 0) >= 5;
  limitsExceeded['Ц'] = false; // Цель всегда доступна

  // Големы: красный, синий, зелёный, жёлтый — только по одному на поле
	limitsExceeded['К1'] = red >= 1;
	limitsExceeded['C1'] = blue >= 1;
	limitsExceeded['З1'] = green >= 1;
	limitsExceeded['Ж1'] = yellow >= 1;
  
  // Линии прямая-угол
  const lineCount = (counts['ПЛ'] || 0) + (counts['УЛ'] || 0);
  limitsExceeded['ПЛ'] = limitsExceeded['УЛ'] = lineCount >= 4;

  // Бонус Уточка - Пружина
  const bonusCount = (counts['ВУТ'] || 0) + (counts['ПРЖ'] || 0);
  limitsExceeded['ВУТ'] = limitsExceeded['ПРЖ'] = bonusCount >= 1;

  // Бонус Aruco1 - Aruco2
  const arucoCount1 = (counts['AM1'] || 0) + (counts['AM2'] || 0);
  limitsExceeded['AM1'] = limitsExceeded['AM2'] = arucoCount1 >= 1;

  // Бонус Aruco3 - Aruco1
  const arucoCount2 = (counts['AM3'] || 0) + (counts['AM1_2'] || 0);
  limitsExceeded['AM3'] = limitsExceeded['AM1_2'] = arucoCount2 >= 1;

  // Бонус Aruco2 - Aruco3
  const arucoCount3 = (counts['AM2_2'] || 0) + (counts['AM3_2'] || 0);
  limitsExceeded['AM2_2'] = limitsExceeded['AM3_2'] = arucoCount3 >= 1;

  return limitsExceeded;
}

//Запись состояния поля в локальное хранилище
function saveStateToLocalStorage() {
    const nameInput = document.getElementById('levelNameInput');
    const descriptionInput = document.getElementById('levelDescription');
    
    const checkboxes = Object.fromEntries(
        Array.from(document.querySelectorAll('[data-field]')).map(cb => [
            cb.dataset.field,
            cb.checked
        ])
    );
    
    const bonusCheckbox = document.getElementById('useBonusTokensCheckbox');
    localStorage.setItem('useBonusTokens', bonusCheckbox?.checked);

    const state = {
        version: 2,
        grid,
        checkboxes,
        name: nameInput?.value || '',
        description: descriptionInput?.value || '',
        editorMode: editorModeSwitcher.value,
        puzzleIcons: selectedPuzzleIcons,
        currentLayer,
        userFieldPositions,
        fieldImageIndices: Object.fromEntries(
            Array.from(document.querySelectorAll('.grid-field')).map(img => [
                img.dataset.fieldKey,
                parseInt(img.dataset.imageIndex || '0')
            ])
        ),
        useBonusTokens: bonusCheckbox?.checked || false
    };
    localStorage.setItem('mapEditorState', JSON.stringify(state));

    // Загружаем существующие повороты (исправленная строка)
    const existingRotations = JSON.parse(localStorage.getItem('tokenRotations') || '{}');

    const rotations = {};

    // Сохраняем повороты из DOM и grid
    for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 10; col++) {
            for (let layer = 1; layer <= 3; layer++) {
                const tokenName = grid[row][col][layer-1];
                if (!tokenName) continue;

                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                const wrapper = cell?.querySelector(`.token-wrapper[data-layer="${layer}"]`);
                
                // Получаем поворот из DOM или из предыдущего сохранения
                let rotation = 0;
                if (wrapper) {
                    rotation = extractRotation(wrapper.style.transform);
                } else {
                    const key = `rotation_${row}_${col}_${tokenName}_layer${layer}`;
                    rotation = JSON.parse(localStorage.getItem('tokenRotations') || {})[key] || 0;
                }

                const key = `rotation_${row}_${col}_${tokenName}_layer${layer}`;
                rotations[key] = rotation;
            }
        }
    }

    localStorage.setItem('tokenRotations', JSON.stringify(rotations));

    function extractRotation(transform) {
        if (!transform || transform === 'none') return 0;
        const rotateStart = transform.indexOf('rotate(');
        if (rotateStart === -1) return 0;
        
        const degIndex = transform.indexOf('deg', rotateStart);
        if (degIndex === -1) return 0;
        
        const rotationStr = transform.substring(rotateStart + 7, degIndex).trim();
        const rotation = parseFloat(rotationStr);
        
        return isNaN(rotation) ? 0 : rotation % 360;
    }
}

// Загрузка состояния поля из локального хранилища
function loadStateFromLocalStorage() {
  const savedState = localStorage.getItem('mapEditorState');
  if (!savedState) return;

  let parsedState;
  try {
    parsedState = JSON.parse(savedState);
  } catch (e) {
    console.error("Ошибка: localStorage.getItem('mapEditorState') содержит некорректный JSON", e);
    alert("Не удалось загрузить сохранённое состояние — формат данных повреждён. Будет использовано начальное состояние.");
    localStorage.removeItem('mapEditorState');

    // Сброс чекбоксов
    document.querySelectorAll('[data-field]').forEach(cb => {
      cb.checked = cb.dataset.field === "4x4";
    });

    // Дефолтные позиции фоновых полей
    userFieldPositions["4x4"] = { row: 0, col: 3 };
    userFieldPositions["2x4_1"] = { row: 0, col: 0 };
    userFieldPositions["2x4_2"] = { row: 0, col: 8 };
    userFieldPositions["4x2_1"] = { row: 0, col: 0 };
    userFieldPositions["4x2_2"] = { row: 0, col: 6 };

    return;
  }

  // --- МИГРАЦИЯ ---
  if (!parsedState.version || parsedState.version < 2) {
    console.warn("Обнаружена старая версия данных. Выполняем миграцию...");
    parsedState.version = 2;
  }

  // --- ВОССТАНОВЛЕНИЕ СОСТОЯНИЯ ---

  // 1. Восстановление сетки
  if (parsedState.grid) {
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 10; col++) {
        if (parsedState.grid[row] && parsedState.grid[row][col]) {
          grid[row][col] = [...parsedState.grid[row][col]];
        }
      }
    }
  }

  // 2. Восстановление позиций фоновых полей
  Object.keys(userFieldPositions).forEach(key => delete userFieldPositions[key]);
  if (parsedState.userFieldPositions && Object.keys(parsedState.userFieldPositions).length > 0) {
    Object.assign(userFieldPositions, parsedState.userFieldPositions);
  } else {
    userFieldPositions["4x4"] = { row: 0, col: 3 };
    userFieldPositions["2x4_1"] = { row: 0, col: 0 };
    userFieldPositions["2x4_2"] = { row: 0, col: 8 };
    userFieldPositions["4x2_1"] = { row: 0, col: 0 };
    userFieldPositions["4x2_2"] = { row: 0, col: 6 };
  }

  // 3. Восстановление состояния чекбоксов
  document.querySelectorAll('[data-field]').forEach(cb => {
    const key = cb.dataset.field;
    if (parsedState.checkboxes && parsedState.checkboxes[key] !== undefined) {
      cb.checked = parsedState.checkboxes[key];
    }
  });

  // 4. Восстановление названия уровня
  const nameInput = document.getElementById('levelNameInput');
  if (nameInput && parsedState.name !== undefined) {
    nameInput.value = parsedState.name;
  }

  // 5. Восстановление описания уровня
  const descriptionInput = document.getElementById('levelDescription');
  if (descriptionInput && parsedState.description !== undefined) {
    descriptionInput.value = parsedState.description;
  }

  // 6. Восстановление текущего слоя
  if (parsedState.currentLayer !== undefined) {
    currentLayer = parsedState.currentLayer;
    const buttons = document.querySelectorAll('.layer-button');
    buttons.forEach(btn => btn.classList.remove('active'));
    const activeButton = [...buttons].find(btn => parseInt(btn.dataset.layer) === currentLayer);
    if (activeButton) {
      activeButton.classList.add('active');
    }
  } else {
    currentLayer = 1;
  }

  // 7. Восстановление изображений фоновых полей
  if (parsedState.fieldImageIndices) {
    drawGameFields(parsedState.fieldImageIndices);
    Object.entries(parsedState.fieldImageIndices).forEach(([key, index]) => {
      localStorage.setItem(`fieldImageIndex_${key}`, index);
    });
  }

  // 8. Восстановление режима редактора
  if (parsedState.editorMode) {
    editorModeSwitcher.value = parsedState.editorMode;
    puzzlePanel.style.display = parsedState.editorMode === 'puzzle' ? 'block' : 'none';
  }

  // 9. Восстановление выбранных иконок головоломок
  if (parsedState.puzzleIcons) {
    selectedPuzzleIcons = [...parsedState.puzzleIcons];
  } else {
    selectedPuzzleIcons = ['', '', '', '', ''];
  }

  // 10. Восстановление поворотов токенов
    const savedRotations = JSON.parse(localStorage.getItem('tokenRotations') || '{}');
    if (savedRotations) {
        // Применяем повороты сразу при загрузке
        document.querySelectorAll('.grid-cell').forEach(cell => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            for (let layer = 1; layer <= 3; layer++) {
                const tokenName = grid[row][col][layer-1];
                if (!tokenName) continue;

                const key = `rotation_${row}_${col}_${tokenName}_layer${layer}`;
                const rotation = savedRotations[key] || 0;
                
                // Сохраняем поворот в localStorage для последующего использования
                localStorage.setItem(key, rotation.toString());
            }
        });
    }

  // 11. Восстановление состояния чекбокса бонусных токенов
  const useBonusTokensCheckbox = document.getElementById('useBonusTokensCheckbox');
  if (useBonusTokensCheckbox) {
    const savedUseBonus = localStorage.getItem('useBonusTokens') === 'true';
    useBonusTokensCheckbox.checked = savedUseBonus;
    toggleBonusTokenVisibility();
  }

  // 12. Обновление всех ячеек
  document.querySelectorAll('.grid-cell').forEach(cell => {
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
	  // Обновляем ячейку для всех слоёв
	  for (let layer = 1; layer <= 3; layer++) {
		updateCell(cell, row, col, layer);
	  }
  });

  // 13. Финальные шаги
  validateLimits();
  updateTokenCounters();
  updateTokenStyles();
  updatePuzzleIconsDisplay();
}

async function ensureImagesLoaded() {
  const images = document.querySelectorAll('img');
  await Promise.all(Array.from(images).map(img => {
    if (img.complete) return Promise.resolve();
    return new Promise(resolve => {
      img.onload = resolve;
      img.onerror = resolve; // Продолжаем даже если есть ошибки
    });
  }));
}

//Сохранение уровня в PNG
document.getElementById('saveButton').addEventListener('click', async function() { // Добавил async
  try {
    // === Функция для гарантированной загрузки изображений ===
    async function ensureImagesLoaded() {
      const images = document.querySelectorAll('img');
      const promises = [];
      
      images.forEach(img => {
        if (img.complete && img.naturalWidth !== 0) return;
        
        promises.push(new Promise(resolve => {
          img.onload = resolve;
          img.onerror = resolve; // Продолжаем в любом случае
        }));
      });

      // Даем изображениям 5 секунд на загрузку
      await Promise.race([
        Promise.all(promises),
        new Promise(resolve => setTimeout(resolve, 5000))
      ]);
    }

    // Ждем загрузки всех изображений
    await ensureImagesLoaded();

    const container = document.querySelector('.main-grid-container');
    if (!container) {
      alert("Контейнер не найден.");
      return;
    }

    const levelNameInput = document.getElementById('levelNameInput');
    let levelName = levelNameInput?.value.trim();
    const fileName = levelName ? transliterate(levelName) + '.png' : 'bg_level.png';

    // === СКРЫВАЕМ ЦВЕТНЫЕ ФОНЫ СЛОЁВ ===
    const bgLayers = document.querySelectorAll('[data-bg-layer="true"]');
    const removedLayers = [];
    
    bgLayers.forEach(el => {
      removedLayers.push({
        parent: el.parentElement,
        element: el
      });
      el.remove();  // Полностью удаляем из DOM
    });

    // === СКРЫВАЕМ ГРАНИЦЫ ЯЧЕЕК ДЛЯ ЧИСТОГО ИЗОБРАЖЕНИЯ ===
    const elementsToHideBorders = container.querySelectorAll('.grid-cell, #layer0 > div');
    const originalStyles = [];
    elementsToHideBorders.forEach(el => {
      originalStyles.push({ el, border: el.style.border });
      el.style.border = 'none';
    });

    function restoreStyles() {
      // Восстанавливаем границы ячеек
      originalStyles.forEach(({el, border}) => {
        el.style.border = border;
      });

      // Восстанавливаем отображение цветных фонов
      removedLayers.forEach(({ parent, element }) => {
        parent.appendChild(element);
      });
    }

    const ImgScale = 2; // Коэффициент масштаба сохранения

    // === РЕНДЕРИМ КОНТЕЙНЕР В canvas ===
    const canvas = await html2canvas(container, {
      backgroundColor: null,
      scale: window.devicePixelRatio * ImgScale,
      ignoreElements: (element) => element.hasAttribute('data-bg-layer'),
      async: true,
      logging: true,
      useCORS: true,
      allowTaint: true,
      imageTimeout: 10000,
      ignoreElements: (element) => {
        return element.style.opacity === '0' || 
               element.style.visibility === 'hidden';
      }
    });

    // === НАХОДИМ МИН/МАКС ГРАНИЦЫ СЕТКИ (без белых краев) ===
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
    const step = 5;

    for (let y = 0; y < canvas.height; y += step) {
      for (let x = 0; x < canvas.width; x += step) {
        const index = (y * canvas.width + x) * 4;
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];
        const a = data[index + 3];

        if (a === 0) continue;

        const isWhite = (
          r > 250 && g > 250 && b > 250
        );

        if (!isWhite) {
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }

    if (minX > maxX || minY > maxY) {
      alert("Нет видимого содержимого для сохранения.");
      restoreStyles();
      return;
    }

    const padding = 10;
    minX = Math.max(0, minX - padding);
    minY = Math.max(0, minY - padding);
    maxX = Math.min(canvas.width, maxX + padding);
    maxY = Math.min(canvas.height, maxY + padding);

    const width = maxX - minX;
    const height = maxY - minY;

    // === ОБРЕЗАЕМ ИЗОБРАЖЕНИЕ СЕТКИ ===
    const croppedCanvas = document.createElement('canvas');
    croppedCanvas.width = width;
    croppedCanvas.height = height;

    const croppedCtx = croppedCanvas.getContext('2d');
    croppedCtx.fillStyle = "rgba(0, 0, 0, 0)";
    croppedCtx.fillRect(0, 0, width, height);

    croppedCtx.drawImage(
      canvas,
      minX, minY, width, height,
      0, 0, width, height
    );

    let icons = [];
    const puzzlePanel = document.getElementById('puzzleIconsContainer');
    const editorMode = editorModeSwitcher.value;
    
    if (editorMode === 'puzzle') {
      const iconElements = puzzlePanel?.querySelectorAll('img.puzzle-icon') || [];
      icons = Array.from(iconElements);
    }

    if (!icons.length && editorMode !== 'puzzle') {
      downloadImage(croppedCanvas, fileName);
      restoreStyles();
      return;
    }

    // === ОБРАБОТКА ИКОНОК ГОЛОВОЛОМОК ===
    const iconSize = 50 * ImgScale;
    const gap = 15 * ImgScale;
    const panelHeight = 50 * ImgScale;
    const totalWidth = icons.length * iconSize + (icons.length - 1) * gap;

    const iconCanvas = document.createElement('canvas');
    iconCanvas.width = totalWidth;
    iconCanvas.height = panelHeight;
    const iconCtx = iconCanvas.getContext('2d');

    await Promise.all(icons.map((icon, i) => {
      return new Promise(resolve => {
        if (!icon || !icon.src || icon.src.includes('empty.png')) {
          resolve();
          return;
        }

        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = icon.src;

        img.onload = () => {
          iconCtx.drawImage(img, i * (iconSize + gap), 0, iconSize, iconSize);
          resolve();
        };

        img.onerror = () => resolve();
      });
    }));

    // === СОЗДАНИЕ ФИНАЛЬНОГО ИЗОБРАЖЕНИЯ ===
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = Math.max(iconCanvas.width, croppedCanvas.width);
    finalCanvas.height = iconCanvas.height + croppedCanvas.height + 20;

    const finalCtx = finalCanvas.getContext('2d');
    finalCtx.fillStyle = "rgba(0, 0, 0, 0)";
    finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

    // Центрируем панель головоломок
    const startX = (finalCanvas.width - iconCanvas.width) / 2;
    finalCtx.drawImage(iconCanvas, startX, 0);
    
    // Добавляем игровое поле
    finalCtx.drawImage(croppedCanvas, 0, iconCanvas.height + 20);

    // === СОХРАНЕНИЕ ===
    const link = document.createElement('a');
    link.download = fileName;
    link.href = finalCanvas.toDataURL('image/png');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Восстанавливаем стили
    restoreStyles();

  } catch (error) {
    console.error("Ошибка при сохранении:", error);
    alert("Произошла ошибка при сохранении изображения.");
    
    // Восстанавливаем стили в случае ошибки
    const elementsToHideBorders = document.querySelectorAll('.grid-cell, #layer0 > div');
    const originalStyles = [];
    elementsToHideBorders.forEach(el => {
      originalStyles.push({ el, border: el.style.border });
      el.style.border = 'none';
    });
    
    const bgLayers = document.querySelectorAll('[data-bg-layer="true"]');
    const removedLayers = [];
    bgLayers.forEach(el => {
      removedLayers.push({
        parent: el.parentElement,
        element: el
      });
      el.remove();
    });
    
    // Вызываем restoreStyles если он определен
    if (typeof restoreStyles === 'function') {
      restoreStyles();
    }
  }
});

// Вспомогательная функция для скачивания
function downloadImage(canvas, filename) {
  const link = document.createElement('a');
  link.download = filename;
  link.href = canvas.toDataURL('image/png');
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// Очистка игрового поля
document.getElementById('clearButton').addEventListener('click', () => {
  if (confirm("Вы уверены, что хотите очистить уровень и начать заново? Вернуть уровень назад будет нельзя!")) {

    localStorage.clear();

    // === Очистка сетки ===
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 10; col++) {
        grid[row][col] = ['', '', ''];
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (cell) cell.innerHTML = '';
      }
    }

    // === Очистка пользовательских позиций полей ===
    Object.keys(userFieldPositions).forEach(key => delete userFieldPositions[key]);

    // === Восстанавливаем поле 4x4 по умолчанию ===
    const default4x4 = { row: 0, col: 3 };
    userFieldPositions["4x4"] = default4x4;
    
    // === Очистка названия и описания уровня ===
    const nameInput = document.getElementById('levelNameInput');
    const descriptionInput = document.getElementById('levelDescription');
    if (nameInput) nameInput.value = ''; // Очистка названия
    if (descriptionInput) descriptionInput.value = ''; // Очистка описания

    // === Сбрасываем чекбоксы ===
    document.querySelectorAll('[data-field]').forEach(cb => {
      cb.checked = cb.dataset.field === "4x4"; // Только 4x4 остаётся включённым
      cb.disabled = false; // Все доступны
    });

    // === СБРОС ИНДЕКСОВ КАРТИНОК ПОЛЕЙ ===
    document.querySelectorAll('.grid-field').forEach(img => {
      img.src = fieldImages[img.dataset.fieldKey][0]; // ставим первую картинку
      img.dataset.imageIndex = 0;
      localStorage.removeItem(`fieldImageIndex_${img.dataset.fieldKey}`); // удаляем из хранилища
    });

    // === Перерисовываем поля ===
    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

    // === Обновляем отображение ячеек ===
    document.querySelectorAll('.grid-cell').forEach(cell => {
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      updateCell(cell, row, col);
    });

    // === Сброс лимитов и стилей ===
    validateLimits();
    updateTokenCounters();
    updateTokenStyles();

    currentLayer = 1;
    const buttons = document.querySelectorAll('.layer-button');
    buttons.forEach(btn => btn.classList.remove('active'));
    buttons[1].classList.add('active'); // Слой 1

    // === Сохраняем чистое состояние ===
    saveStateToLocalStorage();
  }
});


function updateFieldCheckboxes() {
  // Обрабатываем каждую пару отдельно
  const pairs = [
    ['2x4_1', '4x2_1'],
    ['2x4_2', '4x2_2']
  ];

  pairs.forEach(([oldKey, newKey]) => {
    const oldField = document.querySelector(`input[data-field="${oldKey}"]`);
    const newField = document.querySelector(`input[data-field="${newKey}"]`);

    if (!oldField || !newField) return;

    if (newField.checked) {
      oldField.checked = false;
      oldField.disabled = true;
    } else if (!newField.checked && !document.querySelector(`input[data-field="${newKey === '4x2_1' ? '4x2_2' : '4x2_1'}"]`).checked) {
      oldField.disabled = false;
    }
  });
}

document.querySelectorAll('.new-field').forEach(cb => {
  cb.addEventListener('change', () => {
    updateFieldCheckboxes();
    
    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

  });
});


// Пары взаимоисключающих полей
const mutuallyExclusivePairs = [
  ['2x4_1', '4x2_1'],
  ['2x4_2', '4x2_2']
];

function updateMutualExclusion() {
  // Сначала разблокируем все чекбоксы
  document.querySelectorAll('[data-field]').forEach(cb => {
    cb.disabled = false;
  });

  // Обрабатываем каждую пару отдельно
  mutuallyExclusivePairs.forEach(([key1, key2]) => {
    const cb1 = document.querySelector(`input[data-field="${key1}"]`);
    const cb2 = document.querySelector(`input[data-field="${key2}"]`);

    if (!cb1 || !cb2) return;

    if (cb1.checked) {
      cb2.checked = false;
      cb2.disabled = true;
    } else if (cb2.checked) {
      cb1.checked = false;
      cb1.disabled = true;
    }
  });
}

// Привязываем к событиям изменения состояния чекбоксов
document.querySelectorAll('[data-field]').forEach(cb => {
  cb.addEventListener('change', () => {
    updateMutualExclusion();
    
    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

  });
});

// Вызываем при загрузке страницы
updateMutualExclusion();

// === Сохранение уровня в JSON с поворотами ===
document.getElementById('saveLevelButton').addEventListener('click', () => {
  const levelNameInput = document.getElementById('levelNameInput');
  let levelName = levelNameInput.value.trim();
  if (!levelName) {
    alert("Введите название уровня!");
    return;
  }
  const latinName = transliterate(levelName);

  // === Получаем текущее состояние редактора ===
  const mapEditorState = localStorage.getItem('mapEditorState');
  if (!mapEditorState) {
    alert("Нет данных для сохранения уровня.");
    return;
  }

  try {
    const loaded = JSON.parse(mapEditorState);

    // === Добавляем имя уровня ===
    loaded.name = levelName;

    // === Получаем повороты из localStorage ===
    const tokenRotations = localStorage.getItem('tokenRotations');
    if (tokenRotations) {
      try {
        loaded.rotations = JSON.parse(tokenRotations);
      } catch (e) {
        console.warn("Ошибка парсинга rotations:", e);
        loaded.rotations = {};
      }
    } else {
      loaded.rotations = {}; // если нет поворотов — всё равно добавляем пустой объект
    }

    // === Сохраняем в файл JSON ===
    const blob = new Blob([JSON.stringify(loaded, null, 2)], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${latinName}.json`;
    link.click();

    // === (Опционально) Сохраняем в localStorage под именем ===
    localStorage.setItem(`savedLevel_${latinName}`, JSON.stringify(loaded));

    alert(`Файл уровня "${levelName}.json" успешно сохранён.`);
  } catch (e) {
    console.error("Ошибка при подготовке уровня к сохранению:", e);
    alert("Не удалось сохранить уровень — произошла ошибка.");
  }
});


//Загрузка уровня из JSON
document.getElementById('loadLevelButton').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const loaded = JSON.parse(text);

      // === ШАГ 1: Загружаем данные в grid и другие переменные ===
      for (let r = 0; r < 10; r++) {
        for (let c = 0; c < 10; c++) {
          grid[r][c] = ['', '', ''];
        }
      }

      for (let r = 0; r < loaded.grid.length; r++) {
        for (let c = 0; c < loaded.grid[r].length; c++) {
          if (loaded.grid[r][c]) {
            grid[r][c] = [...loaded.grid[r][c]];
          }
        }
      }

      // Очистка и заполнение userFieldPositions
      Object.keys(userFieldPositions).forEach(key => delete userFieldPositions[key]);
      if (loaded.userFieldPositions) {
        Object.assign(userFieldPositions, loaded.userFieldPositions);
      }

      // Установка состояния чекбоксов
      document.querySelectorAll('[data-field]').forEach(cb => {
        const key = cb.dataset.field;
        cb.checked = loaded.checkboxes?.[key] ?? false;
      });

      // === ШАГ: Заполняем поля "Название уровня" и "Описание уровня" ===
      const nameInput = document.getElementById('levelNameInput');
      const descriptionInput = document.getElementById('levelDescription');

      if (nameInput) {
        nameInput.value = loaded.name || '';
      }

      if (descriptionInput) {
        descriptionInput.value = loaded.description || '';
      }

      // === Восстановление состояния чекбокса бонусных токенов ===
      const useBonusTokensCheckbox = document.getElementById('useBonusTokensCheckbox');
      if (useBonusTokensCheckbox) {
        useBonusTokensCheckbox.checked = loaded.useBonusTokens || false;
        toggleBonusTokenVisibility(); // Make sure visibility updates accordingly
      }

      // === ШАГ 2: Применяем повороты к токенам через localStorage или напрямую ===
      if (loaded.rotations && typeof loaded.rotations === 'object') {
        Object.entries(loaded.rotations).forEach(([key, value]) => {
          localStorage.setItem(key, value);
        });
        Object.keys(loaded.rotations).forEach(key => {
		  });
      }

      // Применяем повороты к wrapper-элементам
      document.querySelectorAll('.grid-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        for (let layer = 1; layer <= 3; layer++) {
          const tokenName = grid[row][col][layer - 1];
          if (tokenName) {
            const rotationKey = `rotation_${row}_${col}_${tokenName}_layer${layer}`;
            const rotation = loaded.rotations?.[rotationKey] || 
                            parseInt(localStorage.getItem(rotationKey)) || 0;
            
            const wrapper = cell.querySelector(`.token-wrapper[data-token="${tokenName}"]`);
            if (wrapper) {
              wrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
            }
          }
        }
      });

      const fieldImageIndices = loaded.fieldImageIndices || {};
      drawGameFields(fieldImageIndices);

      // === ШАГ 3: Обновляем ячейки с учетом поворотов ===
      document.querySelectorAll('.grid-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        updateCell(cell, row, col);
      });

      validateLimits();
      updateTokenCounters();
      updateTokenStyles();

      // === ШАГ 4: Сохраняем всё в localStorage за один вызов ===
      saveStateToLocalStorage();

      alert(`Уровень "${loaded.name}" успешно загружен.`);

    } catch (e) {
      console.error("Ошибка при чтении JSON:", e);
      alert("Ошибка при загрузке уровня — неверный формат файла.");
    }
  };
  input.click();
});

// Обновление кэша каждые 7 дней
function shouldRefreshCache(timestampKey, maxAgeMs = 7 * 24 * 60 * 60 * 1000) {
  const lastCached = localStorage.getItem(timestampKey);
  return !lastCached || Date.now() - parseInt(lastCached) > maxAgeMs;
}

function cacheImageWithExpiry(url) {
  const timestampKey = `cached_image_timestamp_${url}`;
  const cachedUrlKey = `cached_image_${url}`;

  // Если кэш актуален — возвращаем его
  if (!shouldRefreshCache(timestampKey)) {
    const cached = localStorage.getItem(cachedUrlKey);
    if (cached) {
      return Promise.resolve(cached);
    }
  }

  // Загружаем новое изображение
  return fetch(url)
    .then(response => {
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return response.blob();
    })
    .then(blob => {
      const reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onload = () => {
          localStorage.setItem(cachedUrlKey, reader.result);
          localStorage.setItem(timestampKey, Date.now());
          resolve(reader.result);
        };
        reader.onerror = () => reject(new Error('FileReader error'));
        reader.readAsDataURL(blob);
      });
    })
    .catch(err => {
      console.warn(`Ошибка при загрузке "${url}"`, err);

      // Возвращаем старый кэш, если он есть
      const fallback = localStorage.getItem(cachedUrlKey);
      if (fallback) {
        console.log("Используется старый кэш вместо недоступного изображения");
        return fallback;
      }

      // Иначе — исходный URL
      return url;
    });
}

// Код для зоны корзины
const trashZone = document.getElementById('trashZone');

if (trashZone) {
  // Разрешаем браузеру реагировать на dragover (для поддержки drop)
  trashZone.addEventListener('dragover', e => {
    e.preventDefault();
    trashZone.style.backgroundColor = '#ffebee';
  });

  trashZone.addEventListener('dragleave', () => {
    trashZone.style.backgroundColor = '';
  });

  trashZone.addEventListener('drop', e => {
    e.preventDefault();
    trashZone.style.backgroundColor = '';
    const tokenName = e.dataTransfer.getData('text/plain');
    const fromRow = parseInt(e.dataTransfer.getData('from-row'));
    const fromCol = parseInt(e.dataTransfer.getData('from-col'));

    if (!isNaN(fromRow) && !isNaN(fromCol)) {
      grid[fromRow][fromCol][currentLayer - 1] = '';
      const cell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
      if (cell) {
        updateCell(cell, fromRow, fromCol);
      }
      validateLimits();
      updateTokenCounters();
      updateTokenStyles();
      saveStateToLocalStorage();
    }
  });
}

// === Обработчик чекбокса "Использовать жетоны краудфандинга" и функция их сокрытия
document.getElementById('useBonusTokensCheckbox').addEventListener('change', function () {
  const show = this.checked;

  // Скрываем/показываем элементы на панели
  document.querySelectorAll('.token-pair-wrapper').forEach(wrapper => {
    const isBonusPair = wrapper.querySelector('[data-pair-group="bonus-pair"]');
    const isArucoPair1 = wrapper.querySelector('[data-pair-group="aruco-pair1"]');
    const isArucoPair2 = wrapper.querySelector('[data-pair-group="aruco-pair2"]');
    const isArucoPair3 = wrapper.querySelector('[data-pair-group="aruco-pair3"]');
    if (isBonusPair || isArucoPair) {
      wrapper.style.display = show ? 'inline-block' : 'none';
    }
  });

  // Скрываем/показываем токены на игровом поле
  document.querySelectorAll('.token').forEach(img => {
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName);
    if (token && (token.pairGroup === 'bonus-pair' || token.pairGroup === 'aruco-pair1' || token.pairGroup === 'aruco-pair2' || token.pairGroup === 'aruco-pair3')) {
      img.style.visibility = show ? 'visible' : 'hidden';
    }
  });

  saveStateToLocalStorage();
});


// === Обработчик чекбокса "Использовать жетоны краудфандинга"
document.getElementById('useBonusTokensCheckbox').addEventListener('change', function () {
  toggleBonusTokenVisibility();
  saveStateToLocalStorage();
});

// Отображение бонус-жетонов
function toggleBonusTokenVisibility() {
  const checkbox = document.getElementById('useBonusTokensCheckbox');
  const show = checkbox?.checked;

  // Скрываем/показываем элементы на панели (парные обёртки)
  document.querySelectorAll('.token-pair-wrapper').forEach(wrapper => {
    const isBonusPair = wrapper.querySelector('[data-pair-group="bonus-pair"]');
    const isArucoPair1 = wrapper.querySelector('[data-pair-group="aruco-pair1"]');
    const isArucoPair2 = wrapper.querySelector('[data-pair-group="aruco-pair2"]');
    const isArucoPair3 = wrapper.querySelector('[data-pair-group="aruco-pair3"]');

    if (isBonusPair || isArucoPair1 || isArucoPair2 || isArucoPair3) {
      wrapper.style.display = show ? 'inline-block' : 'none';
    }
  });

  // Скрываем/показываем токены на игровом поле
  document.querySelectorAll('.token').forEach(img => {
    const tokenName = img.alt;
    const token = tokens.find(t => t.name === tokenName);
    if (token && (
      token.pairGroup === 'bonus-pair' ||
      token.pairGroup === 'aruco-pair1' ||
      token.pairGroup === 'aruco-pair2' ||
      token.pairGroup === 'aruco-pair3'
    )) {
      img.style.visibility = show ? 'visible' : 'hidden';
    }
  });
}


// Блок иконок к Головоломкам
const puzzleIconsContainer = document.getElementById('puzzleIconsContainer');

let selectedPuzzleIcons = ['', '', '', '', '']; // до 5 возможных значений

  function updatePuzzleIconsDisplay() {
    const icons = document.querySelectorAll('.puzzle-icon');
    icons.forEach((icon, index) => {
      const key = selectedPuzzleIcons[index];
      if (key) {
        const condition = puzzleConditions.find(c => c.key === key);
        if (condition) {
          icon.src = getCachedImageURL(condition.image);
          icon.alt = condition.key;
        }
      } else {
        icon.src = getCachedImageURL(IMAGE_PREFIX + 'empty.png');
        icon.alt = '';
      }
    });
  }

function createPuzzleIcons() {
  puzzleIconsContainer.innerHTML = '';
  for (let i = 0; i < 5; i++) {
    const wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.textAlign = 'center';

    const icon = document.createElement('img');
    icon.src = IMAGE_PREFIX + 'empty.png'; // путь к прозрачному изображению или фону
    icon.alt = 'empty';
    icon.className = 'puzzle-icon';
    icon.dataset.index = i;

    icon.addEventListener('click', () => {
      cyclePuzzleIcon(icon);
    });

    const label = document.createElement('div');
    label.textContent = `#${i+1}`;
    label.style.fontSize = '10px';
    label.style.marginTop = '4px';

    wrapper.appendChild(icon);
    wrapper.appendChild(label);
    puzzleIconsContainer.appendChild(wrapper);
  }
}

  const puzzleSlots = {
    0: ['lvl1', 'lvl2', 'lvl3', 'lvl4', 'lvl5'], // #1: уровни сложности
    1: ['repeat2', 'condition', 'attack', 'defense', 'bot1', 'bot2'], // #2: бонусы и боты
    2: ['repeat2', 'condition', 'attack', 'defense', 'bot1', 'bot2'], // #3: бонусы и боты
    3: ['repeat2', 'condition', 'attack', 'defense', 'bot1', 'bot2'], // #4: бонусы и боты
    4: ['line1', 'line2', 'line3', 'line4', 'line5', 'line6', 'lineN'] // #5: линии программы
  };

  function cyclePuzzleIcon(icon) {
    const index = parseInt(icon.dataset.index);
    const currentKey = selectedPuzzleIcons[index];

    // Получаем допустимые значения из объекта
    const allowedKeys = puzzleSlots[index] || [];

    // Находим следующий подходящий ключ
    const currentIndex = allowedKeys.indexOf(currentKey);
    const nextIndex = (currentIndex + 1) % (allowedKeys.length + 1); // +1 для empty

    if (nextIndex === allowedKeys.length) {
      // empty
      icon.src = IMAGE_PREFIX + 'empty.png';
      icon.alt = '';
      icon.classList.remove('active');
      selectedPuzzleIcons[index] = '';
    } else {
      const condition = puzzleConditions.find(c => c.key === allowedKeys[nextIndex]);
      if (condition) {
        icon.src = getCachedImageURL(condition.image);
        icon.alt = condition.key;
        icon.classList.add('active');
        selectedPuzzleIcons[index] = condition.key;
      }
    }

    saveStateToLocalStorage();
  }

  const editorModeSwitcher = document.getElementById('editorModeSwitcher');
  const puzzlePanel = document.getElementById('puzzlePanelIcons');

  editorModeSwitcher.addEventListener('change', () => {
    const mode = editorModeSwitcher.value;
    if (mode === 'puzzle') {
      puzzlePanel.style.display = 'block';
    } else {
      puzzlePanel.style.display = 'none';
    }
    saveStateToLocalStorage();
  });

  // === Загрузка состояния режима при старте ===
  function loadEditorMode() {
    const savedState = localStorage.getItem('mapEditorState');
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState);
        if (parsedState.editorMode) {
          editorModeSwitcher.value = parsedState.editorMode;
          if (parsedState.editorMode === 'puzzle') {
            puzzlePanel.style.display = 'block';
          }
        }
      } catch (e) {
        console.error("Ошибка загрузки режима:", e);
      }
    }
  }

// Функция перерисовки полей с учетом их стороны

  function rebuildBackgroundFields(fieldImageIndices) {
    const layer0 = document.getElementById('layer0');
    layer0.innerHTML = ''; // Очищаем старые фоновые поля

    document.querySelectorAll('[data-field]').forEach(cb => {
      const key = cb.dataset.field;
      if (cb.checked) {
        const pos = userFieldPositions[key] || fieldPositions[key] || { row: 0, col: 0 };
        let rowsSpan, colsSpan;

        if (key === '4x4') {
          rowsSpan = colsSpan = 4;
        } else if (key.startsWith('2x4')) {
          rowsSpan = 4;
          colsSpan = 2;
        } else if (key.startsWith('4x2')) {
          rowsSpan = 2;
          colsSpan = 4;
        }

        const images = fieldImages[key];
        const index = fieldImageIndices?.[key] ?? 0;
        const imgUrl = images[index];

        const cachedUrl = getCachedImageURL(imgUrl);

        const img = createField(cachedUrl, key, pos.row, pos.col, rowsSpan, colsSpan);
        img.dataset.imageIndex = index;
        layer0.appendChild(img);
      }
    });

    if (currentLayer === 0) {
      makeDraggable([...layer0.children]);
    }
  }


// При первой загрузке или при F5
// === Инициализация при загрузке страницы ===

loadStateFromLocalStorage(); // <-- загружаем из localStorage
toggleBonusTokenVisibility();
createPuzzleIcons();
updatePuzzleIconsDisplay();

    const fieldImageIndices = {};
    document.querySelectorAll('.grid-field').forEach(img => {
      fieldImageIndices[img.dataset.fieldKey] = parseInt(img.dataset.imageIndex || '0');
    });
    drawGameFields(fieldImageIndices);

document.querySelectorAll('.grid-cell').forEach(cell => {
  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  updateCell(cell, row, col);
});

validateLimits();
updateTokenCounters();
updateTokenStyles();
toggleBonusTokenVisibility();
loadEditorMode();

</script>
</body>
</html>
